---
title: 计算机网络期末复习
date: Thu Jan 04 2024 13:23:25 GMT+0800 (China Standard Time)
abstract: 期末复习
category: Course Review
---

# 计算机网络期末复习

## Chapter 1 计算机网络概述

### 计算机网络、Internet

构成、通信基础设施

> 端系统通过**通信链路**（communication link）和**分组交换机**（packet switch）的网络连接到一起。不同的通信链路能够以不同的速率传输数据，链路的**传输速率**（transmission rate）以比特/秒度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包就是**分组**（packet）。这些分组通过网络发送到目的端系统，在哪里被装配成初始数据。
>
> 分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。两种常见的分组交换机是**路由器**（router）和**链路层交换机**（link-layer switch）。
>
> 端系统通过**因特网服务提供商**（ISP）接入因特网。端系统、分组交换机和其他因特网部件都要运行多个**协议**（protocal），这些协议控制因特网中信息的接收和发送。

<font color="red">网络协议</font>

> **协议**（protocal）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其他事件所采取的动作。

### 网络边缘

<font color="red">位置</font>

> 通常把与因特网相连的计算机和其他设备成为端系统，端系统也被称为主机（host）。主机有时候又被进一步话分成两类：**客户端**（client）和**服务器**（server）。今天，大部分提供搜索结果、电子邮件、Web 网页、视频和移动应用内容的服务器都属于大型**数据中心**（data center）。

家庭接入

> 家庭住户通常从提供本地电话接入的本地电话公司获得**数字用户线**（Digital Subscriber Line，DSL）因特网接入，因此在使用 DSL 时，用户的本地电话公司也是他的 ISP。每个用户的 DSL 调制解调器使用现有的电话线与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的 DSL 调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在 DSLAM 处被转换回数字形式。
>
> 住宅电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码。
>
> ![](/assets/net-fig1.png)
>
> DSL 利用电话公司现有的本地电话基础设施，而**电缆因特网接入**（cable Internet access）利用了有线电视公司现有的有线电视基础设施。光缆将电缆头端连接到地区枢纽，从这里通过传统的同轴电缆到达各个家庭。每个地区枢纽通常支持 500~5000 个家庭。因为在这个系统中既应用了光纤也应用了同轴电缆，所以经常被称为混合光纤同轴（Hybrid Fiber Coax，HFC）系统。
>
> ![](/assets/net-fig2.png)
>
> **光纤到户**（Fiber To The Home，FTTH）是一种住宅接入技术，提供了一条从本地中心局直接到家庭的光线路径。FTTH 能够提供大约每秒千兆比特的因特网接入速率。

企业接入

> **以太网**用户使用双绞线与一台以太网交换机相连；以太网交换机或以这种方式相连的交换机网络，则再与更大的因特网相连。
>
> 今天许多家庭将宽带住宅接入（即电缆调制解调器或 DSL）与廉价的无线局域网技术结合起来，以组成强大的家用网络。一个家庭网络的组成如下：一台漫游的便携机、多个与因特网相连的家电产品或一台有线 PC；一个与无线 PC 和家中其它无线设备通信的基站（无线接入点）；一个将无线接入点和家中其他无线设备与因特网相连的家用路由器。

广域无线接入

> 便携移动设备越来越多地用来在移动环境中发信息。这些设备应用了与蜂窝移动电话相同的无线基础设施，通过蜂窝网提供商运营的基站来发送和接收分组。与 WiFi 不同的是，用户仅需要距离基站数万米（而不是几十米）的范围内。

### 网络核心

<font color="red">位置</font>

> 网络核心指互联因特网端系统的分组交换机和链路构成的网状网络。
>
> ![](/assets/net-fig3.png)

<font color="red">分组交换（存储转发）</font>

> 为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，成为**分组**（packet）。在源和目的地之间，每个分组都通过通信链路和**分组交换机**（packet switch）传送。分组以等于该链路最大传输速率的速度通过通信链路。
>
> 分组交换机在链路的输入端使用**存储转发传输**（store-and-forward transmission）机制。存储转发是指一个分组被传输到下一个链路之前，其整个分组必须完全到达路由器。如果忽略传播时延，通过由 $N$ 条速率均为 $R$ 的链路组成的路径，从源到目的地发送一个分组，其端到端时延是 $d_{\text{end-end}}=N\dfrac{L}{R}$。
>
> 每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个**输出缓存**（output buffer），它用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，这就是输出缓存的**排队时延**（queueing delay）。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了，在此情况下，将会出现**分组丢失（丢包）**（packet loss）。

电路交换

> 在电路交换网络中，当两台主机要通信时，该网络在两台主机之间创建一条专用的**端到端连接**（end-to-end connection）。链路中的**电路**是通过**频分复用**（FDM）或**时分复用**（TDM）来实现的

<font color="red">多路复用（时分、频分）</font>

> 对于 FDM，链路的频谱由跨越链路创建的所有连接共享，在连接期间为每条连接专设一个频段。对于 TDM 链路，实践被划分为固定时段的帧，并且每个帧又被划分为固定数量的时隙；当网络跨越一条链路创建连接时，网络在每个帧中为该连接指定一个时隙，这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。
>
> ![](/assets/net-fig4.png)
>
> 电路交换的端到端时延通常由传输时间和建立链路时间组成，其中传输速率为链路最大传输速率除以时隙数量得到。

<font color="red">电路交换与分组交换的比较</font>

> 在同样的网络资源配置条件下，分组交换允许更多用户使用网络：假设每个用户的活跃周期是变化的，在活跃期间用户以恒定速率产生数据，在静止期间用户不产生数据。对于电路交换，在所有的时间内必须为每个用户预留足够的带宽，而分组交换在通过链路时基本没有时延。
>
> 分组交换更适合于对突发式数据传输，因为分组交换不必建立连接，并且活跃用户可以以全部链路速率发送其分组。
>
> 然而分组交换的过度使用可能会造成网络拥塞，因此可靠的数据传输需要协议来约束。

网络结构

> ![](/assets/net-fig5.png)

### 网络体系结构

<font color="red">分层的优点与原则</font>

> 概念化：结构清晰，便于标示网络组件，以及描述其相互关系。
>
> 结构化：模块化更易于维护和系统升级。改变某一层服务的实现不会影响系统中的其他层次。
>
> 系统分层实现的好处（降低复杂性、提高灵活性）：独立性强，适应性强，易于实现和维护，有利于促进标准化
>
> 系统分层实现的原则：层数应始终，每层功能应明确，层与层应相互独立，层间单向引用

<font color="red">层间通信（相邻服务，对等协议）</font>

> 服务与协议的区别
> - 服务（service）：低层实体向上层实体提供它们之间通信的能力，是通过原语（primitive）来操作的，垂直
> - 协议（protocol）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平
>
> 服务与协议的联系
> - 本层协议的实现要靠下层提供的服务来实现
> - 本层实体通过协议为上层提供更高级的服务

数据封装

> ![](/assets/net-fig6.png)

<font color="red">网络体系结构定义</font>

> TBD.

<font color="red">OSI 体系结构模型</font>

> - 应用层（application layer）：提供应用程序便捷的网络服务调用
> - 表示层（presentation layer）：关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构
> - 会话层（session layer）：在应用程序之间建立和维持会话，并使会话获得同步
> - 传输层（transport layer）：将数据从源端口发送到目的端口（进程到进程）
> - 网络层（network layer）：将数据包跨越网络从源设备发送到目的设备
> - 数据链路层（data-link layer）：实现相邻（neighboring）网络实体间的数据传输，从物理层的比特流中提取出完整的帧
> - 物理层（physical layer）：定义如何在信道上传输 0/1

<font color="red">TCP/IP 体系结构模型及二者比较</font>

> ![](/assets/net-fig7.png)
>
> OSI 模型的不足
> - 从未真正被实现：TCP/IP 已成为事实标准，OSI 缺少厂家支持
> - 技术实现糟糕：OSI 分层欠缺技术考虑：会话层、表示层很少内容；数据链路层、网络层内容繁杂，模型和协议过于复杂；分层间功能重复：差错控制、流量控制等在不同层反复出现
> - 非技术因素：TCP/IP 实现为 UNIX 的一部分，免费；OSI 被认为是政府和机构的强加标准
>
> TCP/IP 模型的不足
> - 核心概念未能体现：未明确区分服务、接口和协议等核心概念
> - 不具备通用性：不适于描述 TCP/IP 之外的其他协议栈
> - 混用接口与分层的设计：链路层和物理层一起被定义为网络接口层，而非真正意义上的分层
> - 模型欠缺完整性：未包含物理层与数据链路层

### 网络性能

<font color="red">分组时延（处理、排队、传输、传播）</font>

> 1. 节点处理时延：检查比特级差错，检查分组首部和决定将分组导向何处
> 2. 排队时延：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
> 3. 传输时延：记链路带宽为 $R(\text{bps})$，分组长度为 $L(\text{bit})$，则传输时延即将分组发送到链路上的时间 $\frac LR$
> 4. 传播时延：记链路长度为 $d(\text{m})$，传播速率为 $s(\text{m/s})$，则传播时延为 $\frac ds$
>
> 记分组到达队列的平均速率为 $a$，流量强度即为 $\frac{La}R$。
> - $\frac{La}R\sim 0$：平均排队时延很小
> - $\frac{La}R\rightarrow 1$：时延变得很大
> - $\frac{La}R>1$：队列长度趋于无穷大，平均时延趋于无穷大

丢包

> 链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组将会丢失。丢失的分组可能会被前一个节点或源端系统重传，或根本不重传。

吞吐量

> 在源端和目标端之间传输的速率（数据量/单位时间）
> - 瞬间吞吐量：在一个时间点的速率
> - 平均吞吐量：在一个长时间内平均值
>
> 端到端平均吞吐 $\min\{R_1,R_2,\cdots,R_n\}$

## Chapter 2 应用层

### 应用层协议

<font color="red">位置</font>

> 运行在端系统中。

<font color="red">含义</font>

> 定义了运行在不同端系统上的应用程序进程如何相互传递报文，包含了交换的报文类型、报文的语法、语义，以及时序关系相应规则等。

<font color="red">网络应用架构（C/S、P2P）</font>

> C/S 架构：
> - 服务器：一直运行，拥有固定的 IP 地址和周知的端口号
> - 客户端：主动与服务器通信，与互联网有间歇性的连接，可能是动态 IP 地址，不直接与其他客户端通信
>
> P2P 架构：
> - （几乎）没有一直运行的服务器
> - 任意端系统之间可以进行通信
> - 每一个节点既是客户端又是服务器
> - 参与的主机间歇性连接且可以改变 IP 地址
>
> 混合架构

<font color="red">进程通信（接口、地址）</font>

> 在一堆进程之间的通信会话场景中，发起通信的进程被表示为**客户**，在会话开始时等待联系的进程是**服务器**。多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过**套接字**（socket）软件接口向网络发送报文和从网络接收报文。
>
> 在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，该地址由 **IP 地址**和**端口号**组成。

网络应用需要的传输服务

> **可靠的数据传输，吞吐量，定时，安全性**
>
> TCP 提供的服务：
> - 可靠的传输服务
> - 流量控制：发送方不会淹没接收方
> - 拥塞控制：当网络出现拥塞时，能抑制发送方
> - 不能提供的服务：时间保证、最小吞吐保证和安全
> - 面向连接：要求在客户端进程和服务器进程之间建立连接
>
> UDP 提供的服务：
> - 不可靠数据传输
> - 不提供的服务：可靠，流量控制，拥塞控制，时间，带宽保证，建立连接

### Web 和 HTTP

Web 页面

> Web 页面由若干个对象组成，对象可以是 HTML 文件、JPEG 图像、多媒体文件等。Web 页面按有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用（链接）

<font color="red">HTTP 协议（80，TCP）</font>

> **HTTP 超文本传输协议**，是 Web 的应用层协议，采用 C/S 模式。使用 **TCP 连接**，默认端口号为 **80**。
>
> HTTP 是无状态的协议。

非持续连接和持续连接

> 非持续 HTTP
> - 最多只有一个对象在 TCP 连接上发送
> - 下载多个对象需要多个 TCP 连接
> - HTTP/1.0 使用非持续连接
>
> 持续 HTTP
> - 的多个对象可以在一个（在客户端和服务器之间的）TCP 连接上传输
> - HTTP/1.1 默认使用持续连接
>
> 非持续 HTTP 的缺点：
> - 每个对象需要 2 个 RTT
> - 操作系统必须为每个 TCP 连接分配资源
> - 浏览器通常打开并行 TCP 连接来获取引用对象
>
> 持续 HTTP
> - 服务器在发送响应后，仍保持 TCP 连接
> - 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
> - 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求
>
> 非流水方式的持续 HTTP
> - 客户端只能在收到前一个响应后才能发出新的请求
> - 每个引用对象花费一个 RTT
>
> 流水方式的持续 HTTP
> - HTTP/1.1 的默认模式
> - 客户端遇到一个引用对象就立即产生一个请求
> - 所有引用（小）对象只花费一个 RTT 是可能的

HTTP 报文

> 两种类型的 HTTP 报文：**请求**、**响应**。
>
> ![](/assets/net-fig8.png)

<font color="red">Cookie</font>

> Cookie 可以维护的信息：
> - 用户验证
> - 购物车
> - 推荐
> - 用户状态

Web 缓存

> Web 缓存（代理服务器）的目标：不访问原始服务器，就能够满足客户的请求。
> - 用户设置浏览器：通过缓存访问 Web
> - 浏览器将所有的 HTTP 请求发给缓存
>   - 在缓存中的对象：缓存直接返回对象
>   - 如果对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
>
> Web 缓存既是客户端又是服务器，同茶馆缓存由 ISP 安装（大学、公司、居民区 ISP）
>
> Web 缓存的优点
> - 降低客户端的请求响应时间
> - 大大减少机构内部网络与 Internet 接入链路上的流量
> - 互联网大量采用缓存：可以使较弱的 ICP 也能有效提供内容

条件 Get

> 条件 Get 的目标：如果 Web 缓存中的对象拷贝是最新的，就不再发送对象
>
> 缓存器：在 HTTP 请求中指定缓存拷贝的日期 `If-modified-since: <date>`
>
> 服务器：如果缓存拷贝是最新的，服务器就发送一个特殊的 HTTP 响应 `HTTP/1.0 304 Not Modified`，但是不发送对象

### E-mail

<font color="red">组成</font>

> **用户代理**，**邮件服务器**，**简单邮件传输协议**（SMTP）

<font color="red">SMTP 协议（25，TCP）</font>

> 使用 **TCP** 在客户端和服务器之间传送报文，端口号为 **25**。
>
> SMTP 使用持久连接，要求报文（首部和主题）为 7 位 ASCII 编码。SMTP 服务器使用 `CRLF.CRLF` 决定报文的尾部。

邮件报文格式

> ![](/assets/net-fig9.png)

从邮件服务器获取报文（POP3，IMAP，HTTP）

> POP3 使用 **TCP**，默认端口号为 **110**。
> 
> POP3 在本地管理文件夹，IMAP 远程管理文件夹。

### DNS

<font color="red">功能（53，UDP）</font>

> DNS 是运行在 **UDP** 之上端口号为 **53** 的应用服务，提供了主机名 - IP 地址的转换功能。

<font color="red">DNS提供的服务</font>

> 主机别名到规范名字的转换（host aliasing）
>
> 邮件服务器别名到邮件服务器的正规名字的转换（mail server aliasing）
>
> 负载均衡（load distribution）

<font color="red">实现方式（两种查询）</font>

> 递归查询：
> - 名字解析负担都放在当前联络的名字服务器上
> - 问题：根服务器的负担太重
>
> 迭代查询：
> - 根（及各级域名）服务器返回的不是查询结果，而是下一个 NS 的地址
> - 最后由权威名字服务器给出解析结果
>
> 缓存：
> - 一旦名字服务器学到了一个映射，就将该映射缓存起来

<font color="red">4 类域名服务器</font>

> 本地名字服务器（local name server）
> - 并不严格属于层次结构
> - 每个 ISP（居民区的 ISP、公司、大学）都有一个本地 DNS 服务器，也成为默认名字服务器
> - 当一个主机发起一个 DNS 查询时，查询被送到其本地 DNS 服务器
>
> 根域名服务器（root name server）
> - 13 个根域名服务器
>
> 顶级域名服务器（top-level domain name server）
> - 负责顶级域名（如 com、org、net、edu、gov）和所有国家级的顶级域名（如 cn、uk、fr）的域名服务器
>
> 权威域名服务器（authoritative name server）
> - 组织机构的 DNS 服务器，提供组织机构服务器（如 Web 和 mail）可访问的主机和 IP 之间的映射
> - 组织机构可以选择自己维护或由某个服务提供商来维护

### P2P 应用（BitTorrent 协议）

> 文件被分为一个个块（256KB），网络中的 peers 发送接收文件块，相互服务
>
> ![](/assets/net-fig10.png)

### 视频流与内容分发网络

> ![](/assets/net-fig11.png)
>
> ![](/assets/net-fig12.png)

### Socket 编程

> UDP Socket 编程
> 
> ![](/assets/net-fig13.png)
>
> TCP Socket 编程
>
> ![](/assets/net-fig14.png)

## Chapter 3 运输层

### 运输层概述

<font color="red">运输层的功能</font>

> 为运行在不同主机上的应用进程之间提供逻辑通信功能（实现端到端的传输）

<font color="red">位置</font>

> 端系统

<font color="red">数据单元</font>

> 报文段

和网络层关系

> 网络层：提供主机之间的逻辑通信
>
> 运输层：为运行在不同主机上的进程之间提供逻辑通信

### 多路复用与多路分解

> 多路复用（multiplexing）：从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装
>
> 多路分解（demultiplexing）：根据报文段的头部信息中的 IP 地址和端口号将接收到的报文段发给正确的套接字（和相对应的应用进程）
>
> 无连接（UDP）多路复用/解复用
> - UDP Socket 标识：目的 IP 地址、目的端口号
>
> 面向连接（TCP）多路复用/解复用
> - TCP Socket 标识：源 IP 地址、源端口号、目的 IP 地址、目的端口号

### UDP 协议

<font color="red">无连接、不可靠</font>

> 无连接
> - UDP 发送端和接收端之间没有握手
> - 每个 UDP 报文段都被独立地处理
>
> “尽力而为”的服务，报文段可能会丢失、乱序

报文格式

> ![](/assets/net-fig15.png)

校验和

> 发送方将报文段的内容视为 16 比特的证书和，将其与校验和字段中的值相加，得到一个结果。接收方执行相同的计算，如果结果为全 1，则认为没有差错，否则认为有差错。
>
> 校验数字相加时，在最高位的进位要回卷到最低位。

### 可靠数据传输机制

<font color="red">差错检测</font>

> rdt2.0：具有比特差错的信道
> - 下层信道可能会出错：将分组中的比特翻转，用校验和来检测比特差错
> - 发送方差错控制编码、缓存
> - 接收方使用编码检错
> - 接收方的反馈：控制报文（ACK，NAK）
> - 发送方收到反馈相应的动作

<font color="red">序号</font>

> rdt2.1：解决 ACK/NAK 出错
> - 如果 ACK/NAK 出错，发送方重传当前分组，需要引入序号
>
> 发送方
> - 在分组中加入序号（0，1）
> - 需要检测 ACK/NAK 是否出错
> - 状态数变成了两倍
>
> 接收方
> - 必须检测接收到的分组是否重复
> - 状态会指示希望接收到的分组序号是 0 还是 1
>
> ![](/assets/net-fig16.png)
>
> ![](/assets/net-fig17.png)
>
> rdt2.2：无 NAK 的协议
> - 功能同 rdt2.1，但只使用 ACK（需要编号）
> - 接收方对最后正确接收的分组发 ACK，以替代 NAK
> - 接收方必须显示地包含被正确接收分组的序号
> - 当收到重复的 ACK 时，发送方与收到 NAK 采取相同的动作：重传当前分组
>
> ![](/assets/net-fig18.png)

<font color="red">定时器</font>

> rdt3.0：具有比特差错和分组丢失的信道
> - 下层信道可能会丢失分组（数据或 ACK）
> - 发送方等待 ACK 一段合理的时间
> - 发送端超时重传：如果到时没有收到 ACK 则重传
> - 重传可能导致数据重复，但用序列号已经可以处理这个问题
> - 接收方必须指明被正确接收的序列号
>
> ![](/assets/net-fig19.png)
>
> rdt3.0 的性能（停等操作）
>
> $T_{\text{transmit}}=\dfrac{L}{R}$
>
> $U_{\text{sender}}=\dfrac{L/R}{RTT+L/R}$
>
> 网络协议限制了物理资源的使用

<font color="red">滑动窗口</font>

> 发送缓冲区
> - 形式：内存中的一个区域，落入缓冲区的分组可以发送
> - 功能：用于存放已发送，但是没有得到确认的分组
> - 必要性：需要重发时可用
>
> 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
>
> 发送缓冲区中的分组
> - 未发送的：落入发送缓冲区的分组，可以连续发送出去
> - 已经发送出去、等待确认的分组：发送缓冲区的分组只有得到确认才能删除
>
> 接收窗口（接收缓冲区）
> - 接收窗口用于控制哪些分组可以接受
> - 只有收到分组需要落入接收窗口内才允许接受，否则丢弃
> - 接收窗口尺寸 Wr=1，则只能顺序接收
> - 接收窗口尺寸 Wr>1，则可以乱序接收
>
> 接收窗口的滑动和发送确认
> - 滑动：低序号的分组到来，接收窗口移动；高序号分组乱序到来，缓存但不交付，不滑动
> - 发送确认：接收窗口尺寸=1，发送连续收到的最大的分组确认（累计确认）；接收窗口尺寸>1，收到分组、发送那个分组的确认（非累计确认）

<font color="red">流水线协议（GBN，SR）</font>

> 流水线协议：提高链路利用率
> - 允许发送方在未得到对方确认的情况下一次发送多个分组
> - 必须增加序号的范围：用多个比特表示分组的序号
> - 在发送方/接收方要有缓冲区
>
> 回退 N 步（GBN）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收端丢弃乱序到达的分组，只发送累计确认
> - 发送端拥有最老的未确认分组的定时器，当定时器超时，重传所有的未确认分组
>
> 选择重传（SR）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收方对每个到来的分组单独确认（非累计确认）
> - 发送方为每个未确认的分组保持一个定时器，当定时器超时，只重发超时的未确认分组
>
> 窗口的最大尺寸
> - GBN：$2^n-1$
> - SR：$2^{n-1}$
> - 例如：$n=2$，序列号：0,1,2,3
>   - GBN=3
>   - SR=2

### TCP 协议

<font color="red">报文格式</font>

> ![](/assets/net-fig20.png)

<font color="red">工作原理</font>

> 序号、确认号
> - 序号：报文段首字节在字节流的编号
> - 确认号：期望从另一方收到的下一个字节的序号，累计确认
>
> 往返延时 RTT 和超时
> - $\text{EstimatedRTT}=(1-\alpha)\text{EstimatedRTT}+\alpha\text{SampleRTT}$（指数加权移动平均）
> - $\text{DevRTT}=(1-\beta)\text{DevRTT}+\beta|\text{SampleRTT}-\text{EstimatedRTT}|$
> - $\text{TimeoutInterval}=\text{EstimatedRTT}+4\text{DevRTT}$
>
> 可靠传输机制
> - 从应用层接收数据，创建并发送报文段（不考虑流量控制、拥塞控制），如果定时器没有运行，则启动定时器
> - 超时：重传后沿最老的报文段，重启定时器
> - 收到确认：如果是对尚未确认的报文段的确认，则更新已被确认的报文段序号；如果还有未被确认的报文段，重启定时器
>
> ```
> NextSeqNum = InitialSeqNumber
> SendBase = InitialSeqNumber
>
> loop (永远) {
>   switch(事件)
>     事件：从上面应用程序接收到数据 e
>       if (定时器没有运行)
>         启动定时器
>       向 IP 传送报文段
>       NextSeqNum = NextSeqNum + length(data)
>       break;
>
>     事件：定时器超时
>       重传具有最小序号但仍未应答的报文段
>       启动定时器
>       break;
>
>     事件：收到 ACK，具有 ACK 字段值 y
>       if (y > SendBase) {
>         SendBase = y
>         if (还有未被确认的报文段)
>           启动定时器
>       }
>       break;
> }
> ```
>
> 快速重传
> - 超时周期往往太长，通过重复的 ACK 来检测报文段丢失：发送方通常连续发送大量报文段，如果报文段丢失，通常会引起多个重复的 ACK
> - 如果发送方收到同一数据的 3 个冗余 ACK，则重传具有最小序号的段（在定时器超时之前）

<font color="red">流量控制</font>

> 接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出
>
> 接收方在其向发送方的 TCP 段头部的 rwnd 字段“通告”其空闲缓冲区大小，发送方限制未确认字节的个数小于等于接收方发送过来的 rwnd 值，保证接收方不会被淹没

<font color="red">连接建立（三次握手）</font>

> ![](/assets/net-fig21.png)

<font color="red">连接释放（四次挥手）</font>

> ![](/assets/net-fig22.png)

### 拥塞控制

拥塞原因与代价

> 原因：太多数据被发送到网络中，网络来不及处理
>
> 代价：较大的排队时延、重传丢弃的分组

<font color="red">拥塞控制方法（端到端、网络辅助）</font>

> 端到端拥塞控制：通过对网络行为的观察（如分组丢失和时延）来推断用色的发生
>
> 网络辅助拥塞控制：网络层设备件（路由器）向发送方提供关于网络中拥塞状态的显式反馈信息

<font color="red">TCP 拥塞控制</font>

> 拥塞控制和流量控制联合动作：发送端控制*发送但是未确认的量*同时满足拥塞控制和流量控制要求
>
> 慢启动、拥塞避免、快速恢复
>
> ![](/assets/net-fig23.png)

## Chapter 4 网络层：数据平面

### 网络层概述

<font color="red">位置</font>

> 每一个主机和路由器，提供主机到主机的通信功能（点到点传输）

<font color="red">数据单元</font>

> 数据报

<font color="red">功能</font>

> 数据报转发（数据平面）：路由器将分组从输入链路移动到适当的输出链路，属于路由器本地动作
>
> 路由选择（控制平面）：分组从源到目的端所采用的路径，属于端到端路径的网络范围内的一个过程，两种实现方式（传统的路由算法、软件定义网络 SDN）

网络服务模型

> Internet 网络层提供**尽力而为**的服务

### 路由器结构

<font color="red">输入端口</font>

> 输入端口要执行将一条输入的物理链路连接到路由器的物理层功能。
> 
> 执行需要与位于入链路另一端接口交互的数据链路层功能。
>
> 完成转发表查找与转发功能，以便转发到路由器交换结构部分的分组能出现在适当的输出端口。
>
> 输入端口转发：基于目的地的转发（最长前缀匹配）

<font color="red">输出端口</font>

> 输出端口存储经过交换结构转发给它的分组，并将这些分组传输到输出链路。

<font color="red">交换结构</font>

> 交换结构位于一台路由器的核心部位，分组才能实际地从一个输入端口交换（即转发）到一个输出端口中。
>
> 通过内存交换
> - 在 CPU 直接控制下的交换，采用传统计算机
> - 分组被拷贝到系统内存，CUP 从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口
> - 转发速率被内存的带宽限制（数据报通过总线两遍）
> - 一次只能转发一个分组
>
> 通过总线交换
> - 数据报通过共享总线，从输入端口转发到输出端口
> - **总线竞争**：交换速度受限于总线带宽
> - 依次处理一个分组
>
> 通过互联网络（crossbar）的交换
> - 同时并发地转发多个分组，克服总线带宽限制
> - 当分组从端口 A 到达，转发给端口 Y：控制器短接相应的两个总线

<font color="red">路由选择处理器</font>

> 执行选路协议，维护选路信息与转发表，并执行路由器中的网络管理功能。

### 分组调度

先进先出

> 按照分组到来的次序发送。如果分组到达一个满的队列，
> - tail drop：丢弃刚到达的分组
> - priority：根据优先权丢弃/移除分组
> - random：随机丢弃/移除

优先权

> 发送最高优先权的分组。多类，不同类别有不同的优先权。

循环（Round Robin）

> 多类，循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类。

加权公平排队

> 一般化的 Round Robin，在一段时间内，每个队列得到的服务时间和权重成正比，每个类再每一个循环中获得不同权重的服务量。

### IPv4 协议

<font color="red">报文格式</font>

> ![](/assets/net-fig24.png)

<font color="red">分片</font>

> 网络链路有 MTU（最大传输单元），代表链路层帧所能携带的最大数据长度
>
> 大的 IP 数据报再网络上被分片（fragmented），一个数据报被分割成若干个小的数据报（相同的 ID，不同的偏移量，最后一个分片标记为 0）
> - “重组”只在最终的目标主机进行
> - IP 头部的信息被用于标识、排序相关分片
>
> ![](/assets/net-fig25.png)

<font color="red">IP 地址</font>

> IP 地址：32 位，对主机或者路由器的接口编址
>
> 接口：主机/路由器和物理链路的连接处
> - 路由器通常拥有多个接口
> - 主机也有可能有多个接口
> - IP 地址和每一个接口关联
>
> 一个 IP 地址和一个接口相关联

<font color="red">子网划分</font>

> 子网
> - 一个子网内的节点（主机或者路由器）它们的 IP 地址的**高位部分**相同，这些节点构成的网络的一部分叫做子网
> - 无路由器接入，子网内各主机可以在物理上相互直接到达

<font color="red">子网掩码</font>

> 1 指示网络部分，0 指示主机部分，和 IP 地址进行与操作后会得到网络地址

<font color="red">特殊 IP 地址</font>

> 特殊 IP 地址
> - 子网部分全 0：本网络
> - 主机部分全 0：本主机
> - 主机部分全 1：广播地址，这个网络的所有主机
>
> 内网（专用）IP 地址
> - 专用地址：地址空间的一部分供专用地址使用
> - 永远不会被当作公用地址来分配，不会与共用地址重复，只在局部网络中有意义，区分不同的设备
> - 路由器不对目标地址是专用地址的分组进行转发
> - 专用地址范围
>   - 127.\*：环回地址
>   - 10.\*/8
>   - 172.16.\*-172.31.\*/16
>   - 192.168.\*/24

<font color="red">DHCP 功能和工作原理</font>

> 允许主机在加入网络的时候，动态地从服务器那里获得 IP 地址
> - 可以更新对主机在用 IP 地址的租用期
> - 重新启动时，允许重新使用以前用过的 IP 地址
> - 支持移动用户加入该网络
>
> DHCP 返回
> - IP 地址
> - 第一跳路由器的 IP 地址（默认网关）
> - DNS 服务器的域名和 IP 地址
> - 子网掩码（指示地质部分的网络号和主机号）
>
> ![](/assets/net-fig26.png)

NAT 功能和工作原理

> 本地网络只有一个有效 IP 地址
> - 不需要从 ISP 分配一块地址，可用一个 IP 地址用于所有的（局域网）设备
> - 可以在局域网改变设备的地址情况下而无需通知外界
> - 可以改变 ISP（地址变化）而不需要改变内部的设备地址
> - 局域网内部的设备没有明确的地址，对外不可见
>
> 工作原理
> - 外出数据包：替换源地址和端口号位 NAT IP 地址和新的端口号，目标 IP 和端口不变
> - 在 NAT 转换表中记录每个转换替换对
> - 进入数据包：替换目标 IP 地址和端口号，采用存储在 NAT 表中的 mapping 表项
>
> ![](/assets/net-fig27.png)
 
### IPv6 协议

<font color="red">产生的动机</font>

> 32 位 IP 地址空间完全分配；需要进一步加快处理/转发速度；促进 QoS

与 IPv4 的区别

> - 扩大地址容量：128 位
> - 简化首部：40 字节
> - 取消分片
> - 取消首部校验和字段
> - 流标签来保证 QoS

## Chapter 5 网络层：控制平面

### 路由选择算法

<font color="red">链路状态算法（主要思想、实例）</font>

> 工作流程
> 1. 发现相邻节点，获知对方网络地址
> 2. 测量到相邻节点的代价（延迟，开销）
> 3. 组装一个分组，描述相邻节点的情况
> 4. 将分组通过扩散的方法发到所有其他路由器
> 5. 通过 Dijkstra 算法找出最短路径
>
> ![](/assets/net-fig28.png)

<font color="red">距离向量算法（主要思想、实例）</font>

> 基本思想
> - 各路由器维护一张路由表
> - 各路由器与相邻路由器交换路由表
> - 根据获得的路由信息，更新路由表
>
> ![](/assets/net-fig29.png)

<font color="red">两者比较</font>

> ![](/assets/net-fig30.png)

### 域内路由协议

<font color="red">OSPF 的工作原理和功能</font>

> 使用 LS 算法
> - LS 分组在网络中（一个 AS 内部）分发
> - 全局网络拓扑、代价在每一个节点中都保持
> - 路由计算采用 Dijkstra 算法
>
> OSPF 通告信息中携带：每一个邻居路由器一个表项
>
> 通告信息回传遍 AS 全部（通过泛洪），在 IP 数据报上直接传送 OSPF 报文（而不是通过 UDP 和 TCP）

### 域间路由协议

<font color="red">BGP（eBGP、iBGP）的工作原理和功能</font>

> - eBGP：从邻居 AS 处获得前缀的可达性信息（BGP 允许每个子网向因特网的其余部分通告它的存在）
> - iBGP：向该 AS 内部的所有路由器传播这些可达性信息
>
> 基于距离向量算法（路径向量）
> - 不仅仅是距离向量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单 DV 算法的路由环路问题
>
> ![](/assets/net-fig31.png)

BGP 路由选择策略

> 路由器可能获得一个网络前缀的多个路径，路由器需要进行路径的选择
> - 本地偏好值属性：偏好策略决定
> - 最短 AS-PATH：AS 的跳数
> - 最近的 NEXT-HOP 路由器：热土豆路由
> - 附加的判据：使用 BGP 标示

区分域内域间路由的原因

> 随着路由器数目不断增长，选路信息的计算、存储及通信的开销将高得不可实现。
>
> 每个 ISP 都希望按自己的意愿运行路由器（如运行其选择的某种选路算法），或对外部隐藏其内部网络的细节，因此在每个 AS 内部的路由器都运行同样的选路算法（AS 内部路由选择协议）并且有彼此的信息，在一个 AS 边缘的网关路由器来负责向本 AS 之外的目的地转发分组，在 AS 之间，各 AS（网关路由器）运行相同的 AS 间路由选择协议。

### <font color="red">Internet 控制报文协议的功能（ICMP）</font>

> 主机和路由器用来交互网络层信息：报告差错情况，回显请求/回答
>
> Traceroute 实现
> - 源端向目的端发送 UDP 数据段，第一个数据段设置 TTL=1，第二个数据段设置 TTL=2，以此类推
> - 路由器由于 TTL=0 而丢弃数据段，向源端发送 ICMP 报文，报告数据段被丢弃，ICMP 报文中包含路由器的 IP 地址等信息