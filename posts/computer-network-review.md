---
title: 计算机网络期末复习
date: Thu Jan 04 2024 13:23:25 GMT+0800 (China Standard Time)
abstract: 期末复习
category: Course Review
---

# 计算机网络期末复习

## Chapter 1 计算机网络概述

### 计算机网络、Internet

构成、通信基础设施

> 端系统通过**通信链路**（communication link）和**分组交换机**（packet switch）的网络连接到一起。不同的通信链路能够以不同的速率传输数据，链路的**传输速率**（transmission rate）以比特/秒度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包就是**分组**（packet）。这些分组通过网络发送到目的端系统，在哪里被装配成初始数据。
>
> 分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。两种常见的分组交换机是**路由器**（router）和**链路层交换机**（link-layer switch）。
>
> 端系统通过**因特网服务提供商**（ISP）接入因特网。端系统、分组交换机和其他因特网部件都要运行多个**协议**（protocal），这些协议控制因特网中信息的接收和发送。

<font color="red">网络协议</font>

> **协议**（protocal）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其他事件所采取的动作。

### 网络边缘

<font color="red">位置</font>

> 通常把与因特网相连的计算机和其他设备成为端系统，端系统也被称为主机（host）。主机有时候又被进一步话分成两类：**客户端**（client）和**服务器**（server）。今天，大部分提供搜索结果、电子邮件、Web 网页、视频和移动应用内容的服务器都属于大型**数据中心**（data center）。

家庭接入

> 家庭住户通常从提供本地电话接入的本地电话公司获得**数字用户线**（Digital Subscriber Line，DSL）因特网接入，因此在使用 DSL 时，用户的本地电话公司也是他的 ISP。每个用户的 DSL 调制解调器使用现有的电话线与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的 DSL 调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在 DSLAM 处被转换回数字形式。
>
> 住宅电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码。
>
> ![](/assets/net-fig1.png)
>
> DSL 利用电话公司现有的本地电话基础设施，而**电缆因特网接入**（cable Internet access）利用了有线电视公司现有的有线电视基础设施。光缆将电缆头端连接到地区枢纽，从这里通过传统的同轴电缆到达各个家庭。每个地区枢纽通常支持 500~5000 个家庭。因为在这个系统中既应用了光纤也应用了同轴电缆，所以经常被称为混合光纤同轴（Hybrid Fiber Coax，HFC）系统。
>
> ![](/assets/net-fig2.png)
>
> **光纤到户**（Fiber To The Home，FTTH）是一种住宅接入技术，提供了一条从本地中心局直接到家庭的光线路径。FTTH 能够提供大约每秒千兆比特的因特网接入速率。

企业接入

> **以太网**用户使用双绞线与一台以太网交换机相连；以太网交换机或以这种方式相连的交换机网络，则再与更大的因特网相连。
>
> 今天许多家庭将宽带住宅接入（即电缆调制解调器或 DSL）与廉价的无线局域网技术结合起来，以组成强大的家用网络。一个家庭网络的组成如下：一台漫游的便携机、多个与因特网相连的家电产品或一台有线 PC；一个与无线 PC 和家中其它无线设备通信的基站（无线接入点）；一个将无线接入点和家中其他无线设备与因特网相连的家用路由器。

广域无线接入

> 便携移动设备越来越多地用来在移动环境中发信息。这些设备应用了与蜂窝移动电话相同的无线基础设施，通过蜂窝网提供商运营的基站来发送和接收分组。与 WiFi 不同的是，用户仅需要距离基站数万米（而不是几十米）的范围内。

### 网络核心

<font color="red">位置</font>

> 网络核心指互联因特网端系统的分组交换机和链路构成的网状网络。
>
> ![](/assets/net-fig3.png)

<font color="red">分组交换（存储转发）</font>

> 为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，成为**分组**（packet）。在源和目的地之间，每个分组都通过通信链路和**分组交换机**（packet switch）传送。分组以等于该链路最大传输速率的速度通过通信链路。
>
> 分组交换机在链路的输入端使用**存储转发传输**（store-and-forward transmission）机制。存储转发是指一个分组被传输到下一个链路之前，其整个分组必须完全到达路由器。如果忽略传播时延，通过由 $N$ 条速率均为 $R$ 的链路组成的路径，从源到目的地发送一个分组，其端到端时延是 $d_{\text{end-end}}=N\dfrac{L}{R}$。
>
> 每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个**输出缓存**（output buffer），它用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，这就是输出缓存的**排队时延**（queueing delay）。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了，在此情况下，将会出现**分组丢失（丢包）**（packet loss）。

电路交换

> 在电路交换网络中，当两台主机要通信时，该网络在两台主机之间创建一条专用的**端到端连接**（end-to-end connection）。链路中的**电路**是通过**频分复用**（FDM）或**时分复用**（TDM）来实现的

<font color="red">多路复用（时分、频分）</font>

> 对于 FDM，链路的频谱由跨越链路创建的所有连接共享，在连接期间为每条连接专设一个频段。对于 TDM 链路，实践被划分为固定时段的帧，并且每个帧又被划分为固定数量的时隙；当网络跨越一条链路创建连接时，网络在每个帧中为该连接指定一个时隙，这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。
>
> ![](/assets/net-fig4.png)
>
> 电路交换的端到端时延通常由传输时间和建立链路时间组成，其中传输速率为链路最大传输速率除以时隙数量得到。

<font color="red">电路交换与分组交换的比较</font>

> 在同样的网络资源配置条件下，分组交换允许更多用户使用网络：假设每个用户的活跃周期是变化的，在活跃期间用户以恒定速率产生数据，在静止期间用户不产生数据。对于电路交换，在所有的时间内必须为每个用户预留足够的带宽，而分组交换在通过链路时基本没有时延。
>
> 分组交换更适合于对突发式数据传输，因为分组交换不必建立连接，并且活跃用户可以以全部链路速率发送其分组。
>
> 然而分组交换的过度使用可能会造成网络拥塞，因此可靠的数据传输需要协议来约束。

网络结构

> ![](/assets/net-fig5.png)

### 网络体系结构

<font color="red">分层的优点与原则</font>

> 概念化：结构清晰，便于标示网络组件，以及描述其相互关系。
>
> 结构化：模块化更易于维护和系统升级。改变某一层服务的实现不会影响系统中的其他层次。
>
> 系统分层实现的好处（降低复杂性、提高灵活性）：独立性强，适应性强，易于实现和维护，有利于促进标准化
>
> 系统分层实现的原则：层数应始终，每层功能应明确，层与层应相互独立，层间单向引用

<font color="red">层间通信（相邻服务，对等协议）</font>

> 服务与协议的区别
> - 服务（service）：低层实体向上层实体提供它们之间通信的能力，是通过原语（primitive）来操作的，垂直
> - 协议（protocol）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平
>
> 服务与协议的联系
> - 本层协议的实现要靠下层提供的服务来实现
> - 本层实体通过协议为上层提供更高级的服务

数据封装

> ![](/assets/net-fig6.png)

<font color="red">网络体系结构定义</font>

> TBD.

<font color="red">OSI 体系结构模型</font>

> - 应用层（application layer）：提供应用程序便捷的网络服务调用
> - 表示层（presentation layer）：关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构
> - 会话层（session layer）：在应用程序之间建立和维持会话，并使会话获得同步
> - 传输层（transport layer）：将数据从源端口发送到目的端口（进程到进程）
> - 网络层（network layer）：将数据包跨越网络从源设备发送到目的设备
> - 数据链路层（data-link layer）：实现相邻（neighboring）网络实体间的数据传输，从物理层的比特流中提取出完整的帧
> - 物理层（physical layer）：定义如何在信道上传输 0/1

<font color="red">TCP/IP 体系结构模型及二者比较</font>

> ![](/assets/net-fig7.png)
>
> OSI 模型的不足
> - 从未真正被实现：TCP/IP 已成为事实标准，OSI 缺少厂家支持
> - 技术实现糟糕：OSI 分层欠缺技术考虑：会话层、表示层很少内容；数据链路层、网络层内容繁杂，模型和协议过于复杂；分层间功能重复：差错控制、流量控制等在不同层反复出现
> - 非技术因素：TCP/IP 实现为 UNIX 的一部分，免费；OSI 被认为是政府和机构的强加标准
>
> TCP/IP 模型的不足
> - 核心概念未能体现：未明确区分服务、接口和协议等核心概念
> - 不具备通用性：不适于描述 TCP/IP 之外的其他协议栈
> - 混用接口与分层的设计：链路层和物理层一起被定义为网络接口层，而非真正意义上的分层
> - 模型欠缺完整性：未包含物理层与数据链路层

### 网络性能

<font color="red">分组时延（处理、排队、传输、传播）</font>

> 1. 节点处理时延：检查比特级差错，检查分组首部和决定将分组导向何处
> 2. 排队时延：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
> 3. 传输时延：记链路带宽为 $R(\text{bps})$，分组长度为 $L(\text{bit})$，则传输时延即将分组发送到链路上的时间 $\frac LR$
> 4. 传播时延：记链路长度为 $d(\text{m})$，传播速率为 $s(\text{m/s})$，则传播时延为 $\frac ds$
>
> 记分组到达队列的平均速率为 $a$，流量强度即为 $\frac{La}R$。
> - $\frac{La}R\sim 0$：平均排队时延很小
> - $\frac{La}R\rightarrow 1$：时延变得很大
> - $\frac{La}R>1$：队列长度趋于无穷大，平均时延趋于无穷大

丢包

> 链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组将会丢失。丢失的分组可能会被前一个节点或源端系统重传，或根本不重传。

吞吐量

> 在源端和目标端之间传输的速率（数据量/单位时间）
> - 瞬间吞吐量：在一个时间点的速率
> - 平均吞吐量：在一个长时间内平均值
>
> 端到端平均吞吐 $\min\{R_1,R_2,\cdots,R_n\}$

## Chapter 2 应用层

### 应用层协议

<font color="red">位置</font>

> 运行在端系统中。

<font color="red">含义</font>

> 定义了运行在不同端系统上的应用程序进程如何相互传递报文，包含了交换的报文类型、报文的语法、语义，以及时序关系相应规则等。

<font color="red">网络应用架构（C/S、P2P）</font>

> C/S 架构：
> - 服务器：一直运行，拥有固定的 IP 地址和周知的端口号
> - 客户端：主动与服务器通信，与互联网有间歇性的连接，可能是动态 IP 地址，不直接与其他客户端通信
>
> P2P 架构：
> - （几乎）没有一直运行的服务器
> - 任意端系统之间可以进行通信
> - 每一个节点既是客户端又是服务器
> - 参与的主机间歇性连接且可以改变 IP 地址
>
> 混合架构

<font color="red">进程通信（接口、地址）</font>

> 在一堆进程之间的通信会话场景中，发起通信的进程被表示为**客户**，在会话开始时等待联系的进程是**服务器**。多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过**套接字**（socket）软件接口向网络发送报文和从网络接收报文。
>
> 在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，该地址由 **IP 地址**和**端口号**组成。

网络应用需要的传输服务

> **可靠的数据传输，吞吐量，定时，安全性**
>
> TCP 提供的服务：
> - 可靠的传输服务
> - 流量控制：发送方不会淹没接收方
> - 拥塞控制：当网络出现拥塞时，能抑制发送方
> - 不能提供的服务：时间保证、最小吞吐保证和安全
> - 面向连接：要求在客户端进程和服务器进程之间建立连接
>
> UDP 提供的服务：
> - 不可靠数据传输
> - 不提供的服务：可靠，流量控制，拥塞控制，时间，带宽保证，建立连接

### Web 和 HTTP

Web 页面

> Web 页面由若干个对象组成，对象可以是 HTML 文件、JPEG 图像、多媒体文件等。Web 页面按有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用（链接）

<font color="red">HTTP 协议（80，TCP）</font>

> **HTTP 超文本传输协议**，是 Web 的应用层协议，采用 C/S 模式。使用 **TCP 连接**，默认端口号为 **80**。
>
> HTTP 是无状态的协议。

非持续连接和持续连接

> 非持续 HTTP
> - 最多只有一个对象在 TCP 连接上发送
> - 下载多个对象需要多个 TCP 连接
> - HTTP/1.0 使用非持续连接
>
> 持续 HTTP
> - 的多个对象可以在一个（在客户端和服务器之间的）TCP 连接上传输
> - HTTP/1.1 默认使用持续连接
>
> 非持续 HTTP 的缺点：
> - 每个对象需要 2 个 RTT
> - 操作系统必须为每个 TCP 连接分配资源
> - 浏览器通常打开并行 TCP 连接来获取引用对象
>
> 持续 HTTP
> - 服务器在发送响应后，仍保持 TCP 连接
> - 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
> - 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求
>
> 非流水方式的持续 HTTP
> - 客户端只能在收到前一个响应后才能发出新的请求
> - 每个引用对象花费一个 RTT
>
> 流水方式的持续 HTTP
> - HTTP/1.1 的默认模式
> - 客户端遇到一个引用对象就立即产生一个请求
> - 所有引用（小）对象只花费一个 RTT 是可能的

HTTP 报文

> 两种类型的 HTTP 报文：**请求**、**响应**。
>
> ![](/assets/net-fig8.png)

<font color="red">Cookie</font>

> Cookie 可以维护的信息：
> - 用户验证
> - 购物车
> - 推荐
> - 用户状态

Web 缓存

> Web 缓存（代理服务器）的目标：不访问原始服务器，就能够满足客户的请求。
> - 用户设置浏览器：通过缓存访问 Web
> - 浏览器将所有的 HTTP 请求发给缓存
>   - 在缓存中的对象：缓存直接返回对象
>   - 如果对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
>
> Web 缓存既是客户端又是服务器，同茶馆缓存由 ISP 安装（大学、公司、居民区 ISP）
>
> Web 缓存的优点
> - 降低客户端的请求响应时间
> - 大大减少机构内部网络与 Internet 接入链路上的流量
> - 互联网大量采用缓存：可以使较弱的 ICP 也能有效提供内容

条件 Get

> 条件 Get 的目标：如果 Web 缓存中的对象拷贝是最新的，就不再发送对象
>
> 缓存器：在 HTTP 请求中指定缓存拷贝的日期 `If-modified-since: <date>`
>
> 服务器：如果缓存拷贝是最新的，服务器就发送一个特殊的 HTTP 响应 `HTTP/1.0 304 Not Modified`，但是不发送对象

### E-mail

<font color="red">组成</font>

> **用户代理**，**邮件服务器**，**简单邮件传输协议**（SMTP）

<font color="red">SMTP 协议（25，TCP）</font>

> 使用 **TCP** 在客户端和服务器之间传送报文，端口号为 **25**。
>
> SMTP 使用持久连接，要求报文（首部和主题）为 7 位 ASCII 编码。SMTP 服务器使用 `CRLF.CRLF` 决定报文的尾部。

邮件报文格式

> ![](/assets/net-fig9.png)

从邮件服务器获取报文（POP3，IMAP，HTTP）

> POP3 使用 **TCP**，默认端口号为 **110**。
> 
> POP3 在本地管理文件夹，IMAP 远程管理文件夹。

### DNS

<font color="red">功能（53，UDP）</font>

> DNS 是运行在 **UDP** 之上端口号为 **53** 的应用服务，提供了主机名 - IP 地址的转换功能。

<font color="red">DNS提供的服务</font>

> 主机别名到规范名字的转换（host aliasing）
>
> 邮件服务器别名到邮件服务器的正规名字的转换（mail server aliasing）
>
> 负载均衡（load distribution）

<font color="red">实现方式（两种查询）</font>

> 递归查询：
> - 名字解析负担都放在当前联络的名字服务器上
> - 问题：根服务器的负担太重
>
> 迭代查询：
> - 根（及各级域名）服务器返回的不是查询结果，而是下一个 NS 的地址
> - 最后由权威名字服务器给出解析结果
>
> 缓存：
> - 一旦名字服务器学到了一个映射，就将该映射缓存起来

<font color="red">4 类域名服务器</font>

> 本地名字服务器（local name server）
> - 并不严格属于层次结构
> - 每个 ISP（居民区的 ISP、公司、大学）都有一个本地 DNS 服务器，也成为默认名字服务器
> - 当一个主机发起一个 DNS 查询时，查询被送到其本地 DNS 服务器
>
> 根域名服务器（root name server）
> - 13 个根域名服务器
>
> 顶级域名服务器（top-level domain name server）
> - 负责顶级域名（如 com、org、net、edu、gov）和所有国家级的顶级域名（如 cn、uk、fr）的域名服务器
>
> 权威域名服务器（authoritative name server）
> - 组织机构的 DNS 服务器，提供组织机构服务器（如 Web 和 mail）可访问的主机和 IP 之间的映射
> - 组织机构可以选择自己维护或由某个服务提供商来维护

### P2P 应用（BitTorrent 协议）

> 文件被分为一个个块（256KB），网络中的 peers 发送接收文件块，相互服务
>
> ![](/assets/net-fig10.png)

### 视频流与内容分发网络

> ![](/assets/net-fig11.png)
>
> ![](/assets/net-fig12.png)

### Socket 编程

> UDP Socket 编程
> 
> ![](/assets/net-fig13.png)
>
> TCP Socket 编程
>
> ![](/assets/net-fig14.png)

## Chapter 3 运输层

### 运输层概述

<font color="red">运输层的功能</font>

> 为运行在不同主机上的应用进程之间提供逻辑通信功能（实现端到端的传输）

<font color="red">位置</font>

> 端系统

<font color="red">数据单元</font>

> 报文段

和网络层关系

> 网络层：提供主机之间的逻辑通信
>
> 运输层：为运行在不同主机上的进程之间提供逻辑通信

### 多路复用与多路分解

> 多路复用（multiplexing）：从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装
>
> 多路分解（demultiplexing）：根据报文段的头部信息中的 IP 地址和端口号将接收到的报文段发给正确的套接字（和相对应的应用进程）
>
> 无连接（UDP）多路复用/解复用
> - UDP Socket 标识：目的 IP 地址、目的端口号
>
> 面向连接（TCP）多路复用/解复用
> - TCP Socket 标识：源 IP 地址、源端口号、目的 IP 地址、目的端口号

### UDP 协议

<font color="red">无连接、不可靠</font>

> 无连接
> - UDP 发送端和接收端之间没有握手
> - 每个 UDP 报文段都被独立地处理
>
> “尽力而为”的服务，报文段可能会丢失、乱序

报文格式

> ![](/assets/net-fig15.png)

校验和

> 发送方将报文段的内容视为 16 比特的证书和，将其与校验和字段中的值相加，得到一个结果。接收方执行相同的计算，如果结果为全 1，则认为没有差错，否则认为有差错。
>
> 校验数字相加时，在最高位的进位要回卷到最低位。

### 可靠数据传输机制

<font color="red">差错检测</font>

> rdt2.0：具有比特差错的信道
> - 下层信道可能会出错：将分组中的比特翻转，用校验和来检测比特差错
> - 发送方差错控制编码、缓存
> - 接收方使用编码检错
> - 接收方的反馈：控制报文（ACK，NAK）
> - 发送方收到反馈相应的动作

<font color="red">序号</font>

> rdt2.1：解决 ACK/NAK 出错
> - 如果 ACK/NAK 出错，发送方重传当前分组，需要引入序号
>
> 发送方
> - 在分组中加入序号（0，1）
> - 需要检测 ACK/NAK 是否出错
> - 状态数变成了两倍
>
> 接收方
> - 必须检测接收到的分组是否重复
> - 状态会指示希望接收到的分组序号是 0 还是 1
>
> ![](/assets/net-fig16.png)
>
> ![](/assets/net-fig17.png)
>
> rdt2.2：无 NAK 的协议
> - 功能同 rdt2.1，但只使用 ACK（需要编号）
> - 接收方对最后正确接收的分组发 ACK，以替代 NAK
> - 接收方必须显示地包含被正确接收分组的序号
> - 当收到重复的 ACK 时，发送方与收到 NAK 采取相同的动作：重传当前分组
>
> ![](/assets/net-fig18.png)

<font color="red">定时器</font>

> rdt3.0：具有比特差错和分组丢失的信道
> - 下层信道可能会丢失分组（数据或 ACK）
> - 发送方等待 ACK 一段合理的时间
> - 发送端超时重传：如果到时没有收到 ACK 则重传
> - 重传可能导致数据重复，但用序列号已经可以处理这个问题
> - 接收方必须指明被正确接收的序列号
>
> ![](/assets/net-fig19.png)
>
> rdt3.0 的性能（停等操作）
>
> $T_{\text{transmit}}=\dfrac{L}{R}$
>
> $U_{\text{sender}}=\dfrac{L/R}{RTT+L/R}$
>
> 网络协议限制了物理资源的使用

<font color="red">滑动窗口</font>

> 发送缓冲区
> - 形式：内存中的一个区域，落入缓冲区的分组可以发送
> - 功能：用于存放已发送，但是没有得到确认的分组
> - 必要性：需要重发时可用
>
> 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
>
> 发送缓冲区中的分组
> - 未发送的：落入发送缓冲区的分组，可以连续发送出去
> - 已经发送出去、等待确认的分组：发送缓冲区的分组只有得到确认才能删除
>
> 接收窗口（接收缓冲区）
> - 接收窗口用于控制哪些分组可以接受
> - 只有收到分组需要落入接收窗口内才允许接受，否则丢弃
> - 接收窗口尺寸 Wr=1，则只能顺序接收
> - 接收窗口尺寸 Wr>1，则可以乱序接收
>
> 接收窗口的滑动和发送确认
> - 滑动：低序号的分组到来，接收窗口移动；高序号分组乱序到来，缓存但不交付，不滑动
> - 发送确认：接收窗口尺寸=1，发送连续收到的最大的分组确认（累计确认）；接收窗口尺寸>1，收到分组、发送那个分组的确认（非累计确认）

<font color="red">流水线协议（GBN，SR）</font>

> 流水线协议：提高链路利用率
> - 允许发送方在未得到对方确认的情况下一次发送多个分组
> - 必须增加序号的范围：用多个比特表示分组的序号
> - 在发送方/接收方要有缓冲区
>
> 回退 N 步（GBN）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收端丢弃乱序到达的分组，只发送累计确认
> - 发送端拥有最老的未确认分组的定时器，当定时器超时，重传所有的未确认分组
>
> 选择重传（SR）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收方对每个到来的分组单独确认（非累计确认）
> - 发送方为每个未确认的分组保持一个定时器，当定时器超时，只重发超时的未确认分组
>
> 窗口的最大尺寸
> - GBN：$2^n-1$
> - SR：$2^{n-1}$
> - 例如：$n=2$，序列号：0,1,2,3
>   - GBN=3
>   - SR=2

### TCP 协议

<font color="red">报文格式</font>

> ![](/assets/net-fig20.png)

<font color="red">工作原理</font>

> 序号、确认号
> - 序号：报文段首字节在字节流的编号
> - 确认号：期望从另一方收到的下一个字节的序号，累计确认
>
> 往返延时 RTT 和超时
> - $\text{EstimatedRTT}=(1-\alpha)\text{EstimatedRTT}+\alpha\text{SampleRTT}$（指数加权移动平均）
> - $\text{DevRTT}=(1-\beta)\text{DevRTT}+\beta|\text{SampleRTT}-\text{EstimatedRTT}|$
> - $\text{TimeoutInterval}=\text{EstimatedRTT}+4\text{DevRTT}$
>
> 可靠传输机制
> - 从应用层接收数据，创建并发送报文段（不考虑流量控制、拥塞控制），如果定时器没有运行，则启动定时器
> - 超时：重传后沿最老的报文段，重启定时器
> - 收到确认：如果是对尚未确认的报文段的确认，则更新已被确认的报文段序号；如果还有未被确认的报文段，重启定时器
>
> ```
> NextSeqNum = InitialSeqNumber
> SendBase = InitialSeqNumber
>
> loop (永远) {
>   switch(事件)
>     事件：从上面应用程序接收到数据 e
>       if (定时器没有运行)
>         启动定时器
>       向 IP 传送报文段
>       NextSeqNum = NextSeqNum + length(data)
>       break;
>
>     事件：定时器超时
>       重传具有最小序号但仍未应答的报文段
>       启动定时器
>       break;
>
>     事件：收到 ACK，具有 ACK 字段值 y
>       if (y > SendBase) {
>         SendBase = y
>         if (还有未被确认的报文段)
>           启动定时器
>       }
>       break;
> }
> ```
>
> 快速重传
> - 超时周期往往太长，通过重复的 ACK 来检测报文段丢失：发送方通常连续发送大量报文段，如果报文段丢失，通常会引起多个重复的 ACK
> - 如果发送方收到同一数据的 3 个冗余 ACK，则重传具有最小序号的段（在定时器超时之前）

<font color="red">流量控制</font>

> 接收方控制发送方，不让发送方发送的太多、太快以至于让接收方的缓冲区溢出
>
> 接收方在其向发送方的 TCP 段头部的 rwnd 字段“通告”其空闲缓冲区大小，发送方限制未确认字节的个数小于等于接收方发送过来的 rwnd 值，保证接收方不会被淹没

<font color="red">连接建立（三次握手）</font>

> ![](/assets/net-fig21.png)

<font color="red">连接释放（四次挥手）</font>

> ![](/assets/net-fig22.png)

### 拥塞控制

拥塞原因与代价

> 原因：太多数据被发送到网络中，网络来不及处理
>
> 代价：较大的排队时延、重传丢弃的分组

<font color="red">拥塞控制方法（端到端、网络辅助）</font>

> 端到端拥塞控制：通过对网络行为的观察（如分组丢失和时延）来推断用色的发生
>
> 网络辅助拥塞控制：网络层设备件（路由器）向发送方提供关于网络中拥塞状态的显式反馈信息

<font color="red">TCP 拥塞控制</font>

> 拥塞控制和流量控制联合动作：发送端控制*发送但是未确认的量*同时满足拥塞控制和流量控制要求
>
> 慢启动、拥塞避免、快速恢复
>
> ![](/assets/net-fig23.png)

## Chapter 4 网络层：数据平面

### 网络层概述

<font color="red">位置</font>

> 每一个主机和路由器，提供主机到主机的通信功能（点到点传输）

<font color="red">数据单元</font>

> 数据报

<font color="red">功能</font>

> 数据报转发（数据平面）：路由器将分组从输入链路移动到适当的输出链路，属于路由器本地动作
>
> 路由选择（控制平面）：分组从源到目的端所采用的路径，属于端到端路径的网络范围内的一个过程，两种实现方式（传统的路由算法、软件定义网络 SDN）

网络服务模型

> Internet 网络层提供**尽力而为**的服务

### 路由器结构

<font color="red">输入端口</font>

> ![](/assets/net-fig40.png)
> 
> 输入端口要执行将一条输入的物理链路连接到路由器的物理层功能。
> 
> 执行需要与位于入链路另一端接口交互的数据链路层功能。
>
> 完成转发表查找与转发功能，以便转发到路由器交换结构部分的分组能出现在适当的输出端口。
>
> 输入端口转发：基于目的地的转发（最长前缀匹配）

<font color="red">输出端口</font>

> 输出端口存储经过交换结构转发给它的分组，并将这些分组传输到输出链路。

<font color="red">交换结构</font>

> 交换结构位于一台路由器的核心部位，分组才能实际地从一个输入端口交换（即转发）到一个输出端口中。
>
> 通过内存交换
> - 在 CPU 直接控制下的交换，采用传统计算机
> - 分组被拷贝到系统内存，CUP 从分组的头部提取出目标地址，查找转发表，找到对应的输出端口，拷贝到输出端口
> - 转发速率被内存的带宽限制（数据报通过总线两遍）
> - 一次只能转发一个分组
>
> 通过总线交换
> - 数据报通过共享总线，从输入端口转发到输出端口
> - **总线竞争**：交换速度受限于总线带宽
> - 依次处理一个分组
>
> 通过互联网络（crossbar）的交换
> - 同时并发地转发多个分组，克服总线带宽限制
> - 当分组从端口 A 到达，转发给端口 Y：控制器短接相应的两个总线

<font color="red">路由选择处理器</font>

> 执行选路协议，维护选路信息与转发表，并执行路由器中的网络管理功能。

### 分组调度

先进先出

> 按照分组到来的次序发送。如果分组到达一个满的队列，
> - tail drop：丢弃刚到达的分组
> - priority：根据优先权丢弃/移除分组
> - random：随机丢弃/移除

优先权

> 发送最高优先权的分组。多类，不同类别有不同的优先权。

循环（Round Robin）

> 多类，循环扫描不同类型的队列，发送完一类的一个分组，再发送下一个类的一个分组，循环所有类。

加权公平排队

> 一般化的 Round Robin，在一段时间内，每个队列得到的服务时间和权重成正比，每个类再每一个循环中获得不同权重的服务量。

### IPv4 协议

<font color="red">报文格式</font>

> ![](/assets/net-fig24.png)

<font color="red">分片</font>

> 网络链路有 MTU（最大传输单元），代表链路层帧所能携带的最大数据长度
>
> 大的 IP 数据报再网络上被分片（fragmented），一个数据报被分割成若干个小的数据报（相同的 ID，不同的偏移量，最后一个分片标记为 0）
> - “重组”只在最终的目标主机进行
> - IP 头部的信息被用于标识、排序相关分片
>
> ![](/assets/net-fig25.png)

<font color="red">IP 地址</font>

> IP 地址：32 位，对主机或者路由器的接口编址
>
> 接口：主机/路由器和物理链路的连接处
> - 路由器通常拥有多个接口
> - 主机也有可能有多个接口
> - IP 地址和每一个接口关联
>
> 一个 IP 地址和一个接口相关联

<font color="red">子网划分</font>

> 子网
> - 一个子网内的节点（主机或者路由器）它们的 IP 地址的**高位部分**相同，这些节点构成的网络的一部分叫做子网
> - 无路由器接入，子网内各主机可以在物理上相互直接到达

<font color="red">子网掩码</font>

> 1 指示网络部分，0 指示主机部分，和 IP 地址进行与操作后会得到网络地址

<font color="red">特殊 IP 地址</font>

> 特殊 IP 地址
> - 子网部分全 0：本网络
> - 主机部分全 0：本主机
> - 主机部分全 1：广播地址，这个网络的所有主机
>
> 内网（专用）IP 地址
> - 专用地址：地址空间的一部分供专用地址使用
> - 永远不会被当作公用地址来分配，不会与共用地址重复，只在局部网络中有意义，区分不同的设备
> - 路由器不对目标地址是专用地址的分组进行转发
> - 专用地址范围
>   - 127.\*：环回地址
>   - 10.\*/8
>   - 172.16.\*-172.31.\*/16
>   - 192.168.\*/24

<font color="red">DHCP 功能和工作原理</font>

> 允许主机在加入网络的时候，动态地从服务器那里获得 IP 地址
> - 可以更新对主机在用 IP 地址的租用期
> - 重新启动时，允许重新使用以前用过的 IP 地址
> - 支持移动用户加入该网络
>
> DHCP 返回
> - IP 地址
> - 第一跳路由器的 IP 地址（默认网关）
> - DNS 服务器的域名和 IP 地址
> - 子网掩码（指示地质部分的网络号和主机号）
>
> ![](/assets/net-fig26.png)

NAT 功能和工作原理

> 本地网络只有一个有效 IP 地址
> - 不需要从 ISP 分配一块地址，可用一个 IP 地址用于所有的（局域网）设备
> - 可以在局域网改变设备的地址情况下而无需通知外界
> - 可以改变 ISP（地址变化）而不需要改变内部的设备地址
> - 局域网内部的设备没有明确的地址，对外不可见
>
> 工作原理
> - 外出数据包：替换源地址和端口号位 NAT IP 地址和新的端口号，目标 IP 和端口不变
> - 在 NAT 转换表中记录每个转换替换对
> - 进入数据包：替换目标 IP 地址和端口号，采用存储在 NAT 表中的 mapping 表项
>
> ![](/assets/net-fig27.png)
 
### IPv6 协议

<font color="red">产生的动机</font>

> 32 位 IP 地址空间完全分配；需要进一步加快处理/转发速度；促进 QoS

与 IPv4 的区别

> - 扩大地址容量：128 位
> - 简化首部：40 字节
> - 取消分片
> - 取消首部校验和字段
> - 流标签来保证 QoS

## Chapter 5 网络层：控制平面

### 路由选择算法

<font color="red">链路状态算法（主要思想、实例）</font>

> 工作流程
> 1. 发现相邻节点，获知对方网络地址
> 2. 测量到相邻节点的代价（延迟，开销）
> 3. 组装一个分组，描述相邻节点的情况
> 4. 将分组通过扩散的方法发到所有其他路由器
> 5. 通过 Dijkstra 算法找出最短路径
>
> ![](/assets/net-fig28.png)

<font color="red">距离向量算法（主要思想、实例）</font>

> 基本思想
> - 各路由器维护一张路由表
> - 各路由器与相邻路由器交换路由表
> - 根据获得的路由信息，更新路由表
>
> ![](/assets/net-fig29.png)

<font color="red">两者比较</font>

> ![](/assets/net-fig30.png)

### 域内路由协议

<font color="red">OSPF 的工作原理和功能</font>

> 使用 LS 算法
> - LS 分组在网络中（一个 AS 内部）分发
> - 全局网络拓扑、代价在每一个节点中都保持
> - 路由计算采用 Dijkstra 算法
>
> OSPF 通告信息中携带：每一个邻居路由器一个表项
>
> 通告信息回传遍 AS 全部（通过泛洪），在 IP 数据报上直接传送 OSPF 报文（而不是通过 UDP 和 TCP）

### 域间路由协议

<font color="red">BGP（eBGP、iBGP）的工作原理和功能</font>

> - eBGP：从邻居 AS 处获得前缀的可达性信息（BGP 允许每个子网向因特网的其余部分通告它的存在）
> - iBGP：向该 AS 内部的所有路由器传播这些可达性信息
>
> 基于距离向量算法（路径向量）
> - 不仅仅是距离向量，还包括到达各个目标网络的详细路径（AS 序号的列表）能够避免简单 DV 算法的路由环路问题
>
> ![](/assets/net-fig31.png)

BGP 路由选择策略

> 路由器可能获得一个网络前缀的多个路径，路由器需要进行路径的选择
> - 本地偏好值属性：偏好策略决定
> - 最短 AS-PATH：AS 的跳数
> - 最近的 NEXT-HOP 路由器：热土豆路由（NEXT-HOP 路由器与自己不在同一个 AS 中）
> - 附加的判据：使用 BGP 标示
>
> 在路由器转发表中增加 AS 外部目的地的步骤
> 1. 从 AS 间协议学到经多个网关可达子网 $x$
> 2. 使用来自 AS 内部协议的路由选择信息，以决定到达每个网关的最低开销路径的开销
> 3. 热土豆路由选择：选择具有最小最低开销的网关
> 4. 从转发表确定通往最低开销网关的接口 $I$，在转发表中加入表项 $(x,I)$
> 

区分域内域间路由的原因

> 随着路由器数目不断增长，选路信息的计算、存储及通信的开销将高得不可实现。
>
> 每个 ISP 都希望按自己的意愿运行路由器（如运行其选择的某种选路算法），或对外部隐藏其内部网络的细节，因此在每个 AS 内部的路由器都运行同样的选路算法（AS 内部路由选择协议）并且有彼此的信息，在一个 AS 边缘的网关路由器来负责向本 AS 之外的目的地转发分组，在 AS 之间，各 AS（网关路由器）运行相同的 AS 间路由选择协议。

### <font color="red">Internet 控制报文协议的功能（ICMP）</font>

> 主机和路由器用来交互网络层信息：报告差错情况，回显请求/回答
>
> Traceroute 实现
> - 源端向目的端发送 UDP 数据段，第一个数据段设置 TTL=1，第二个数据段设置 TTL=2，以此类推
> - 路由器由于 TTL=0 而丢弃数据段，向源端发送 ICMP 报文，报告数据段被丢弃，ICMP 报文中包含路由器的 IP 地址等信息

## Chapter 6 链路层和局域网

### 链路层概述

<font color="red">功能</font>

> 将数据报通过单一通信链路从一个节点移动到相邻节点

<font color="red">数据单元</font>

> 帧

链路层服务

> - 成帧（framing）
> - 链路接入
> - 可靠交付
> - 差错检测和纠正

<font color="red">实现位置</font>

> 链路层功能在“适配器”上实现或者在一个芯片组上
> - 以太网卡；以太网芯片组
> - 实现链路层和相应的物理层功能
>
> 部分链路层功能是运行在主机 CPU 上的软件中实现的

### 差错检测和纠正技术

<font color="red">奇偶校验</font>

> ![](/assets/net-fig32.png)

<font color="red">检验和</font>

> 目标：检测在传输报文段时的错误（如位反转），仅用在传输层
>
> 发送方将报文段看成 16 比特整数，计算所有字段的补码和，将和的反码放在 checksum 字段中
>
> 接收方计算所有字段的补码和，如果结果为全 1，则认为没有差错

<font color="red">循环冗余检验（CRC）</font>

> 将数据比特 D 看成是二进制的数据
>
> 生成多项式 G：双方协商 $r+1$ 位模式（$r$ 次方），生成和检查所使用的位模式
>
> 目标：选择 $r$ 位 CRC 附加位 $R$，使得
> - $D\cdot 2^r\oplus R$ 正好被 $G$ 整除（模 2 除法）
> - 接收方知道 $G$，将 $D\cdot 2^r$ 除以 $G$，如果余数为 0，则认为没有差错
> - 能检出所有少于 $r+1$ 位的突发错误
>
> ![](/assets/net-fig33.png)

### 多路访问链路和协议

<font color="red">多路访问的含义</font>

> 两种类型的链路（一个子网内部链路连接形式）：
> - 点对点
> - 广播（共享线路或媒体）
>
> 多路访问协议
> - 单个共享的广播型链路
> - 2 个或更多站点同时传送，会导致冲突

<font color="red">多路访问控制协议类型（3 类）</font>

> 多路访问协议（介质访问控制协议 MAC）
> - 信道划分：把信道划分成小片（时间、频率、编码），分配片给每个节点专用
> - 随机访问：信道不划分，允许冲突，冲突后恢复
> - 依次轮流：节点依次轮流，但是有很多数据传输的节点可以获得较长的信道使用权

时隙 ALOHA

> 假设所有帧是等长的，时间被划分成相等的时隙，每个时隙可发送一帧。节点只在时隙开始时发送帧，节点在时钟上是同步的。如果两个或多个节点在一个时隙传输，所有的节点都能检测到冲突。
>
> 当节点获取到新的帧，在下一个时隙传输。如果在传输时没有检测到冲突，则传输成功；如果检测到冲突，则传输失败，节点在每一个随后的时隙以概率 $p$ 重传帧直到成功。
>
> ![](/assets/net-fig34.png)

ALOHA

> 无需节点在时间上同步，当有帧需要传输则马上传输。但是冲突的概率增加了一倍。

轮流协议

> ![](/assets/net-fig35.png)
>
> ![](/assets/net-fig36.png)

CSMA（载波侦听多路访问）

> 在传输前侦听信道
> - 如果侦听到信道空闲，传送整个帧
> - 如果侦听到信道忙，推迟传送
>
> 冲突仍然可能发生：由传播延迟造成，两个节点可能侦听不到正在进行的传输，这会导致整个冲突帧的传输时间都被浪费

<font color="red">CSMA/CD 的工作原理</font>

> 以太网 CSMA/CD 算法
> 1. 适配器获取数据报，创建帧
> 2. 发送前：侦听信道 CS
>   - 如果信道空闲，发送帧
>   - 如果信道忙，一直等到闲再发送
> 3. 发送过程中，冲突检测 CD
>   - 没有冲突：发送成功
>   - 检测到冲突：放弃，之后尝试重发
> 4. 发送方适配器检测到冲突，除放弃外，还发送一个 Jam 信号，所有听到冲突的适配器也是如此，强化冲突，让所有站点都知道冲突
> 5. 如果放弃，适配器进入指数退避状态，在第 $m$ 次失败后，适配器随机选择一个 $\{0,1,\cdots,2^{m-1}\}$ 中 $K$，等待 $K\cdot 512$ 位时，然后转到步骤 2

### 局域网

<font color="red">局域网地址（表示和作用）</font>

> 以太网地址（MAC 地址），链路层寻址，6 字节，16 进制表示
>
> 网络地址和 MAC 地址分离
> - IP 地址是分层的，一个子网所有站点网络号一致，路由聚集，减小路由表大小
> - MAC 地址是平面的，网卡在生产时不知道被用于哪个网络，因此给网卡一个唯一的标示，用于区分一个网络内部不同的网卡即可

<font color="red">ARP（功能、工作原理、ARP 表）</font>

> 获取 LAN 节点 IP/MAC 地址的映射
>
> ARP 协议
> 1. A 要发送帧给 B（B 的 IP 地址已知），但 B 的 MAC 地址不在 A 的 ARP 表中
> 2. A **广播**包含 B 的 IP 地址的 ARP 查询包
>   - Dest MAC Address = FF-FF-FF-FF-FF-FF
>   - LAN 上的所有节点都会收到该查询包
> 3. B 接收到 ARP 包，回复 A 自己的 MAC 地址
>   - 帧发送给 A
>   - 用 A 的 MAC 地址（单播）
> 4. A 再自己的 ARP 表中缓存 IP2MAC 地址映射关系，直到信息超时
> 5. ARP 是即插即用的，节点自己创建 ARP 表项，无需网络管理员干预

<font color="red">发送数据报到子网以外</font>

> ![](/assets/net-fig37.png)

### 以太网

<font color="red">拓扑结构</font>

> 总线型：在上世纪 90 年代中期流行
> - 所有节点在一个碰撞域内，一次只允许一个节点发送
> - 可靠性差，如果介质（同轴电缆）破损，截面形成信号的反射，发送节点误认为是冲突
>
> 星型：目前最主流
> - 连接选择：hub 或 switch，现在一般是交换机在中心
> - 每个节点以及相连的交换机端口使用独立的以太网协议，不会和其他节点的发送产生碰撞

帧结构

> ![](/assets/net-fig38.png)
>
> ![](/assets/net-fig39.png)

服务类型（无连接、不可靠）

> 无连接：帧传输前，发送方和接收方之间没有握手
>
> 不可靠：接收方适配器不发送 ACK 或 NAK 给发送方
> - 递交给网络层的数据报流可能有 gap
>
> 以太网的 MAC 协议：采用二进制指数退避的 CSMA/CD 介质访问控制形式

### 交换机

<font color="red">位置</font>

> 链路层设备

<font color="red">功能</font>

> 过滤和转发
> - 过滤：决定一个帧是应该转发到某个接口还是将其丢弃
> - 转发：决定一个帧应该被导向哪个接口，并把该帧移动到这些接口

<font color="red">交换机表（即插即用、自学习）</font>

> 交换机表的表项包含主机的 MAC 地址，到达该 MAC 地址经过的接口，时间戳
>
> 交换机通过学习得到哪些主机（MAC 地址）可以通过哪些端口到达
> - 当接收到帧，交换机学习到发送站点所在的端口（网段）
> - 在交换表中，记录发送方 MAC 地址/进入端口映射关系
>
> 当交换机收到一个帧：
> 1. 记录进入链路，发送主机的 MAC 地址
> 2. 使用目标 MAC 地址对交换表进行索引
> 3. 如果目标 MAC 地址不在交换表中，向所有端口转发（泛洪）
> 4. 如果目标 MAC 地址在交换表中，除了帧到达的端口外，向目标端口转发（解决泛洪）

<font color="red">交换机和路由器的比较</font>

> - 都是存储转发设备，但层次不同
>   - 交换机：链路层设备（检查链路层头部）
>   - 路由器：网络层设备（检查网络层的头部）
> - 都有转发表
>   - 交换机：维护交换表，按照 MAC 地址转发
>     - 执行过滤、自学习和生成树算法
>     - 即插即用：二层设备，速率高
>     - 执行生成树算法，限制广播帧的转发
>     - ARP 表项随着站点数量增多而增多
>   - 路由器：维护路由表，执行路由算法
>     - 路由算法能够避免环路，无需执行生成树算法
>     - 对广播分组做限制
>     - 不是即插即用的，需要配置网络地址（子网前缀）
>     - 三层设备，速率低

### VLAN

<font color="red">划分动机</font>

> 现有拓扑结构的缺点，缺乏流量隔离，交换机的无效使用，用户在组间移动需要改变物理布线。通过将一个交换机上不同的端口分组，每个组构成一个VLAN，就好像将一个物理交换机划分为多个虚拟交换机。通过配置trunk端口并互联，发送到任何VLAN的帧都可以通过trunk端口转发到其他交换机。

方法

> 需要在帧中加入VLAN标签，在trunk端口实现VLAN标签的添加和删除

### <font color="red">综合示例（Web 页面请求的历程）</font>



## Chapter 7 无线网络

### CSMA/CA 协议

利用 RTS 和 CTS 解决了隐藏终端问题