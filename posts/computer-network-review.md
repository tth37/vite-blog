---
title: 计算机网络期末复习
date: Thu Jan 04 2024 13:23:25 GMT+0800 (China Standard Time)
abstract: 期末复习
category: Course Review
---

# 计算机网络期末复习

## Chapter 1 计算机网络概述

### 计算机网络、Internet

构成、通信基础设施

> 端系统通过**通信链路**（communication link）和**分组交换机**（packet switch）的网络连接到一起。不同的通信链路能够以不同的速率传输数据，链路的**传输速率**（transmission rate）以比特/秒度量。当一台端系统要向另一台端系统发送数据时，发送端系统将数据分段，并为每段加上首部字节，由此形成的信息包就是**分组**（packet）。这些分组通过网络发送到目的端系统，在哪里被装配成初始数据。
>
> 分组交换机从它的一条入通信链路接收到达的分组，并从它的一条出通信链路转发该分组。两种常见的分组交换机是**路由器**（router）和**链路层交换机**（link-layer switch）。
>
> 端系统通过**因特网服务提供商**（ISP）接入因特网。端系统、分组交换机和其他因特网部件都要运行多个**协议**（protocal），这些协议控制因特网中信息的接收和发送。

<font color="red">网络协议</font>

> **协议**（protocal）定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文的发送/接收或其他事件所采取的动作。

### 网络边缘

<font color="red">位置</font>

> 通常把与因特网相连的计算机和其他设备成为端系统，端系统也被称为主机（host）。主机有时候又被进一步话分成两类：**客户端**（client）和**服务器**（server）。今天，大部分提供搜索结果、电子邮件、Web 网页、视频和移动应用内容的服务器都属于大型**数据中心**（data center）。

家庭接入

> 家庭住户通常从提供本地电话接入的本地电话公司获得**数字用户线**（Digital Subscriber Line，DSL）因特网接入，因此在使用 DSL 时，用户的本地电话公司也是他的 ISP。每个用户的 DSL 调制解调器使用现有的电话线与位于电话公司的本地中心局（CO）中的数字用户线接入复用器（DSLAM）交换数据。家庭的 DSL 调制解调器得到数字数据后将其转换为高频音，以通过电话线传输给本地中心局；来自许多家庭的模拟信号在 DSLAM 处被转换回数字形式。
>
> 住宅电话线同时承载了数据和传统的电话信号，它们用不同的频率进行编码。
>
> ![](/assets/net-fig1.png)
>
> DSL 利用电话公司现有的本地电话基础设施，而**电缆因特网接入**（cable Internet access）利用了有线电视公司现有的有线电视基础设施。光缆将电缆头端连接到地区枢纽，从这里通过传统的同轴电缆到达各个家庭。每个地区枢纽通常支持 500~5000 个家庭。因为在这个系统中既应用了光纤也应用了同轴电缆，所以经常被称为混合光纤同轴（Hybrid Fiber Coax，HFC）系统。
>
> ![](/assets/net-fig2.png)
>
> **光纤到户**（Fiber To The Home，FTTH）是一种住宅接入技术，提供了一条从本地中心局直接到家庭的光线路径。FTTH 能够提供大约每秒千兆比特的因特网接入速率。

企业接入

> **以太网**用户使用双绞线与一台以太网交换机相连；以太网交换机或以这种方式相连的交换机网络，则再与更大的因特网相连。
>
> 今天许多家庭将宽带住宅接入（即电缆调制解调器或 DSL）与廉价的无线局域网技术结合起来，以组成强大的家用网络。一个家庭网络的组成如下：一台漫游的便携机、多个与因特网相连的家电产品或一台有线 PC；一个与无线 PC 和家中其它无线设备通信的基站（无线接入点）；一个将无线接入点和家中其他无线设备与因特网相连的家用路由器。

广域无线接入

> 便携移动设备越来越多地用来在移动环境中发信息。这些设备应用了与蜂窝移动电话相同的无线基础设施，通过蜂窝网提供商运营的基站来发送和接收分组。与 WiFi 不同的是，用户仅需要距离基站数万米（而不是几十米）的范围内。

### 网络核心

<font color="red">位置</font>

> 网络核心指互联因特网端系统的分组交换机和链路构成的网状网络。
>
> ![](/assets/net-fig3.png)

<font color="red">分组交换（存储转发）</font>

> 为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，成为**分组**（packet）。在源和目的地之间，每个分组都通过通信链路和**分组交换机**（packet switch）传送。分组以等于该链路最大传输速率的速度通过通信链路。
>
> 分组交换机在链路的输入端使用**存储转发传输**（store-and-forward transmission）机制。存储转发是指一个分组被传输到下一个链路之前，其整个分组必须完全到达路由器。如果忽略传播时延，通过由 $N$ 条速率均为 $R$ 的链路组成的路径，从源到目的地发送一个分组，其端到端时延是 $d_{\text{end-end}}=N\dfrac{L}{R}$。
>
> 每台分组交换机有多条链路与之相连。对于每条相连的链路，该分组交换机具有一个**输出缓存**（output buffer），它用于存储路由器准备发往那条链路的分组。如果到达的分组需要传输到某条链路，但发现该链路正忙于传输其他分组，该到达分组必须在输出缓存中等待，这就是输出缓存的**排队时延**（queueing delay）。因为缓存空间的大小是有限的，一个到达的分组可能发现该缓存已被其他等待传输的分组完全充满了，在此情况下，将会出现**分组丢失（丢包）**（packet loss）。

电路交换

> 在电路交换网络中，当两台主机要通信时，该网络在两台主机之间创建一条专用的**端到端连接**（end-to-end connection）。链路中的**电路**是通过**频分复用**（FDM）或**时分复用**（TDM）来实现的

<font color="red">多路复用（时分、频分）</font>

> 对于 FDM，链路的频谱由跨越链路创建的所有连接共享，在连接期间为每条连接专设一个频段。对于 TDM 链路，实践被划分为固定时段的帧，并且每个帧又被划分为固定数量的时隙；当网络跨越一条链路创建连接时，网络在每个帧中为该连接指定一个时隙，这些时隙专门由该连接单独使用，一个时隙（在每个帧内）可用于传输该连接的数据。
>
> ![](/assets/net-fig4.png)
>
> 电路交换的端到端时延通常由传输时间和建立链路时间组成，其中传输速率为链路最大传输速率除以时隙数量得到。

<font color="red">电路交换与分组交换的比较</font>

> 在同样的网络资源配置条件下，分组交换允许更多用户使用网络：假设每个用户的活跃周期是变化的，在活跃期间用户以恒定速率产生数据，在静止期间用户不产生数据。对于电路交换，在所有的时间内必须为每个用户预留足够的带宽，而分组交换在通过链路时基本没有时延。
>
> 分组交换更适合于对突发式数据传输，因为分组交换不必建立连接，并且活跃用户可以以全部链路速率发送其分组。
>
> 然而分组交换的过度使用可能会造成网络拥塞，因此可靠的数据传输需要协议来约束。

网络结构

> ![](/assets/net-fig5.png)

### 网络体系结构

<font color="red">分层的优点与原则</font>

> 概念化：结构清晰，便于标示网络组件，以及描述其相互关系。
>
> 结构化：模块化更易于维护和系统升级。改变某一层服务的实现不会影响系统中的其他层次。
>
> 系统分层实现的好处（降低复杂性、提高灵活性）：独立性强，适应性强，易于实现和维护，有利于促进标准化
>
> 系统分层实现的原则：层数应始终，每层功能应明确，层与层应相互独立，层间单向引用

<font color="red">层间通信（相邻服务，对等协议）</font>

> 服务与协议的区别
> - 服务（service）：低层实体向上层实体提供它们之间通信的能力，是通过原语（primitive）来操作的，垂直
> - 协议（protocol）：对等层实体（peer entity）之间在相互通信的过程中，需要遵循的规则的集合，水平
>
> 服务与协议的联系
> - 本层协议的实现要靠下层提供的服务来实现
> - 本层实体通过协议为上层提供更高级的服务

数据封装

> ![](/assets/net-fig6.png)

<font color="red">网络体系结构定义</font>

> TBD.

<font color="red">OSI 体系结构模型</font>

> - 应用层（application layer）：提供应用程序便捷的网络服务调用
> - 表示层（presentation layer）：关注所传递信息的语法和语义，管理数据的表示方法，传输的数据结构
> - 会话层（session layer）：在应用程序之间建立和维持会话，并使会话获得同步
> - 传输层（transport layer）：将数据从源端口发送到目的端口（进程到进程）
> - 网络层（network layer）：将数据包跨越网络从源设备发送到目的设备
> - 数据链路层（data-link layer）：实现相邻（neighboring）网络实体间的数据传输，从物理层的比特流中提取出完整的帧
> - 物理层（physical layer）：定义如何在信道上传输 0/1

<font color="red">TCP/IP 体系结构模型及二者比较</font>

> ![](/assets/net-fig7.png)
>
> OSI 模型的不足
> - 从未真正被实现：TCP/IP 已成为事实标准，OSI 缺少厂家支持
> - 技术实现糟糕：OSI 分层欠缺技术考虑：会话层、表示层很少内容；数据链路层、网络层内容繁杂，模型和协议过于复杂；分层间功能重复：差错控制、流量控制等在不同层反复出现
> - 非技术因素：TCP/IP 实现为 UNIX 的一部分，免费；OSI 被认为是政府和机构的强加标准
>
> TCP/IP 模型的不足
> - 核心概念未能体现：未明确区分服务、接口和协议等核心概念
> - 不具备通用性：不适于描述 TCP/IP 之外的其他协议栈
> - 混用接口与分层的设计：链路层和物理层一起被定义为网络接口层，而非真正意义上的分层
> - 模型欠缺完整性：未包含物理层与数据链路层

### 网络性能

<font color="red">分组时延（处理、排队、传输、传播）</font>

> 1. 节点处理时延：检查比特级差错，检查分组首部和决定将分组导向何处
> 2. 排队时延：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
> 3. 传输时延：记链路带宽为 $R(\text{bps})$，分组长度为 $L(\text{bit})$，则传输时延即将分组发送到链路上的时间 $\frac LR$
> 4. 传播时延：记链路长度为 $d(\text{m})$，传播速率为 $s(\text{m/s})$，则传播时延为 $\frac ds$
>
> 记分组到达队列的平均速率为 $a$，流量强度即为 $\frac{La}R$。
> - $\frac{La}R\sim 0$：平均排队时延很小
> - $\frac{La}R\rightarrow 1$：时延变得很大
> - $\frac{La}R>1$：队列长度趋于无穷大，平均时延趋于无穷大

丢包

> 链路的队列缓冲区容量有限，当分组到达一个满的队列时，该分组将会丢失。丢失的分组可能会被前一个节点或源端系统重传，或根本不重传。

吞吐量

> 在源端和目标端之间传输的速率（数据量/单位时间）
> - 瞬间吞吐量：在一个时间点的速率
> - 平均吞吐量：在一个长时间内平均值
>
> 端到端平均吞吐 $\min\{R_1,R_2,\cdots,R_n\}$

## Chapter 2 应用层

### 应用层协议

<font color="red">位置</font>

> 运行在端系统中。

<font color="red">含义</font>

> 定义了运行在不同端系统上的应用程序进程如何相互传递报文，包含了交换的报文类型、报文的语法、语义，以及时序关系相应规则等。

<font color="red">网络应用架构（C/S、P2P）</font>

> C/S 架构：
> - 服务器：一直运行，拥有固定的 IP 地址和周知的端口号
> - 客户端：主动与服务器通信，与互联网有间歇性的连接，可能是动态 IP 地址，不直接与其他客户端通信
>
> P2P 架构：
> - （几乎）没有一直运行的服务器
> - 任意端系统之间可以进行通信
> - 每一个节点既是客户端又是服务器
> - 参与的主机间歇性连接且可以改变 IP 地址
>
> 混合架构

<font color="red">进程通信（接口、地址）</font>

> 在一堆进程之间的通信会话场景中，发起通信的进程被表示为**客户**，在会话开始时等待联系的进程是**服务器**。多数应用程序由通信进程对组成，每对中的两个进程互相发送报文。从一个进程向另一个进程发送的报文必须通过下面的网络。进程通过**套接字**（socket）软件接口向网络发送报文和从网络接收报文。
>
> 在一台主机上运行的进程为了向另一台主机上运行的进程发送分组，接收进程需要有一个地址，该地址由 **IP 地址**和**端口号**组成。

网络应用需要的传输服务

> **可靠的数据传输，吞吐量，定时，安全性**
>
> TCP 提供的服务：
> - 可靠的传输服务
> - 流量控制：发送方不会淹没接收方
> - 拥塞控制：当网络出现拥塞时，能抑制发送方
> - 不能提供的服务：时间保证、最小吞吐保证和安全
> - 面向连接：要求在客户端进程和服务器进程之间建立连接
>
> UDP 提供的服务：
> - 不可靠数据传输
> - 不提供的服务：可靠，流量控制，拥塞控制，时间，带宽保证，建立连接

### Web 和 HTTP

Web 页面

> Web 页面由若干个对象组成，对象可以是 HTML 文件、JPEG 图像、多媒体文件等。Web 页面按有一个基本的 HTML 文件，该基本 HTML 文件又包含若干对象的引用（链接）

<font color="red">HTTP 协议（80，TCP）</font>

> **HTTP 超文本传输协议**，是 Web 的应用层协议，采用 C/S 模式。使用 **TCP 连接**，默认端口号为 **80**。
>
> HTTP 是无状态的协议。

非持续连接和持续连接

> 非持续 HTTP
> - 最多只有一个对象在 TCP 连接上发送
> - 下载多个对象需要多个 TCP 连接
> - HTTP/1.0 使用非持续连接
>
> 持续 HTTP
> - 的多个对象可以在一个（在客户端和服务器之间的）TCP 连接上传输
> - HTTP/1.1 默认使用持续连接
>
> 非持续 HTTP 的缺点：
> - 每个对象需要 2 个 RTT
> - 操作系统必须为每个 TCP 连接分配资源
> - 浏览器通常打开并行 TCP 连接来获取引用对象
>
> 持续 HTTP
> - 服务器在发送响应后，仍保持 TCP 连接
> - 在相同客户端和服务器之间的后续请求和响应报文通过相同的连接进行传送
> - 客户端在遇到一个引用对象的时候，就可以尽快发送该对象的请求
>
> 非流水方式的持续 HTTP
> - 客户端只能在收到前一个响应后才能发出新的请求
> - 每个引用对象花费一个 RTT
>
> 流水方式的持续 HTTP
> - HTTP/1.1 的默认模式
> - 客户端遇到一个引用对象就立即产生一个请求
> - 所有引用（小）对象只花费一个 RTT 是可能的

HTTP 报文

> 两种类型的 HTTP 报文：**请求**、**响应**。
>
> ![](/assets/net-fig8.png)

<font color="red">Cookie</font>

> Cookie 可以维护的信息：
> - 用户验证
> - 购物车
> - 推荐
> - 用户状态

Web 缓存

> Web 缓存（代理服务器）的目标：不访问原始服务器，就能够满足客户的请求。
> - 用户设置浏览器：通过缓存访问 Web
> - 浏览器将所有的 HTTP 请求发给缓存
>   - 在缓存中的对象：缓存直接返回对象
>   - 如果对象不在缓存，缓存请求原始服务器，然后再将对象返回给客户端
>
> Web 缓存既是客户端又是服务器，同茶馆缓存由 ISP 安装（大学、公司、居民区 ISP）
>
> Web 缓存的优点
> - 降低客户端的请求响应时间
> - 大大减少机构内部网络与 Internet 接入链路上的流量
> - 互联网大量采用缓存：可以使较弱的 ICP 也能有效提供内容

条件 Get

> 条件 Get 的目标：如果 Web 缓存中的对象拷贝是最新的，就不再发送对象
>
> 缓存器：在 HTTP 请求中指定缓存拷贝的日期 `If-modified-since: <date>`
>
> 服务器：如果缓存拷贝是最新的，服务器就发送一个特殊的 HTTP 响应 `HTTP/1.0 304 Not Modified`，但是不发送对象

### E-mail

<font color="red">组成</font>

> **用户代理**，**邮件服务器**，**简单邮件传输协议**（SMTP）

<font color="red">SMTP 协议（25，TCP）</font>

> 使用 **TCP** 在客户端和服务器之间传送报文，端口号为 **25**。
>
> SMTP 使用持久连接，要求报文（首部和主题）为 7 位 ASCII 编码。SMTP 服务器使用 `CRLF.CRLF` 决定报文的尾部。

邮件报文格式

> ![](/assets/net-fig9.png)

从邮件服务器获取报文（POP3，IMAP，HTTP）

> POP3 使用 **TCP**，默认端口号为 **110**。
> 
> POP3 在本地管理文件夹，IMAP 远程管理文件夹。

### DNS

<font color="red">功能（53，UDP）</font>

> DNS 是运行在 **UDP** 之上端口号为 **53** 的应用服务，提供了主机名 - IP 地址的转换功能。

<font color="red">DNS提供的服务</font>

> 主机别名到规范名字的转换（host aliasing）
>
> 邮件服务器别名到邮件服务器的正规名字的转换（mail server aliasing）
>
> 负载均衡（load distribution）

<font color="red">实现方式（两种查询）</font>

> 递归查询：
> - 名字解析负担都放在当前联络的名字服务器上
> - 问题：根服务器的负担太重
>
> 迭代查询：
> - 根（及各级域名）服务器返回的不是查询结果，而是下一个 NS 的地址
> - 最后由权威名字服务器给出解析结果
>
> 缓存：
> - 一旦名字服务器学到了一个映射，就将该映射缓存起来

<font color="red">4 类域名服务器</font>

> 本地名字服务器（local name server）
> - 并不严格属于层次结构
> - 每个 ISP（居民区的 ISP、公司、大学）都有一个本地 DNS 服务器，也成为默认名字服务器
> - 当一个主机发起一个 DNS 查询时，查询被送到其本地 DNS 服务器
>
> 根域名服务器（root name server）
> - 13 个根域名服务器
>
> 顶级域名服务器（top-level domain name server）
> - 负责顶级域名（如 com、org、net、edu、gov）和所有国家级的顶级域名（如 cn、uk、fr）的域名服务器
>
> 权威域名服务器（authoritative name server）
> - 组织机构的 DNS 服务器，提供组织机构服务器（如 Web 和 mail）可访问的主机和 IP 之间的映射
> - 组织机构可以选择自己维护或由某个服务提供商来维护

### P2P 应用（BitTorrent 协议）

> 文件被分为一个个块（256KB），网络中的 peers 发送接收文件块，相互服务
>
> ![](/assets/net-fig10.png)

### 视频流与内容分发网络

> ![](/assets/net-fig11.png)
>
> ![](/assets/net-fig12.png)

### Socket 编程

> UDP Socket 编程
> 
> ![](/assets/net-fig13.png)
>
> TCP Socket 编程
>
> ![](/assets/net-fig14.png)

## Chapter 3 运输层

### 运输层概述

<font color="red">运输层的功能</font>

> 为运行在不同主机上的应用进程之间提供逻辑通信功能（实现端到端的传输）

<font color="red">位置</font>

> 端系统

<font color="red">数据单元</font>

> 报文段

和网络层关系

> 网络层：提供主机之间的逻辑通信
>
> 运输层：为运行在不同主机上的进程之间提供逻辑通信

### 多路复用与多路分解

> 多路复用（multiplexing）：从多个套接字接收来自多个进程的报文，根据套接字对应的 IP 地址和端口号等信息对报文段用头部加以封装
>
> 多路分解（demultiplexing）：根据报文段的头部信息中的 IP 地址和端口号将接收到的报文段发给正确的套接字（和相对应的应用进程）
>
> 无连接（UDP）多路复用/解复用
> - UDP Socket 标识：目的 IP 地址、目的端口号
>
> 面向连接（TCP）多路复用/解复用
> - TCP Socket 标识：源 IP 地址、源端口号、目的 IP 地址、目的端口号

### UDP 协议

<font color="red">无连接、不可靠</font>

> 无连接
> - UDP 发送端和接收端之间没有握手
> - 每个 UDP 报文段都被独立地处理
>
> “尽力而为”的服务，报文段可能会丢失、乱序

报文格式

> ![](/assets/net-fig15.png)

校验和

> 发送方将报文段的内容视为 16 比特的证书和，将其与校验和字段中的值相加，得到一个结果。接收方执行相同的计算，如果结果为全 1，则认为没有差错，否则认为有差错。
>
> 校验数字相加时，在最高位的进位要回卷到最低位。

### 可靠数据传输机制

<font color="red">差错检测</font>

> rdt2.0：具有比特差错的信道
> - 下层信道可能会出错：将分组中的比特翻转，用校验和来检测比特差错
> - 发送方差错控制编码、缓存
> - 接收方使用编码检错
> - 接收方的反馈：控制报文（ACK，NAK）
> - 发送方收到反馈相应的动作

<font color="red">序号</font>

> rdt2.1：解决 ACK/NAK 出错
> - 如果 ACK/NAK 出错，发送方重传当前分组，需要引入序号
>
> 发送方
> - 在分组中加入序号（0，1）
> - 需要检测 ACK/NAK 是否出错
> - 状态数变成了两倍
>
> 接收方
> - 必须检测接收到的分组是否重复
> - 状态会指示希望接收到的分组序号是 0 还是 1
>
> ![](/assets/net-fig16.png)
>
> ![](/assets/net-fig17.png)
>
> rdt2.2：无 NAK 的协议
> - 功能同 rdt2.1，但只使用 ACK（需要编号）
> - 接收方对最后正确接收的分组发 ACK，以替代 NAK
> - 接收方必须显示地包含被正确接收分组的序号
> - 当收到重复的 ACK 时，发送方与收到 NAK 采取相同的动作：重传当前分组
>
> ![](/assets/net-fig18.png)

<font color="red">定时器</font>

> rdt3.0：具有比特差错和分组丢失的信道
> - 下层信道可能会丢失分组（数据或 ACK）
> - 发送方等待 ACK 一段合理的时间
> - 发送端超时重传：如果到时没有收到 ACK 则重传
> - 重传可能导致数据重复，但用序列号已经可以处理这个问题
> - 接收方必须指明被正确接收的序列号
>
> ![](/assets/net-fig19.png)
>
> rdt3.0 的性能（停等操作）
>
> $T_{\text{transmit}}=\dfrac{L}{R}$
>
> $U_{\text{sender}}=\dfrac{L/R}{RTT+L/R}$
>
> 网络协议限制了物理资源的使用

<font color="red">滑动窗口</font>

> 发送缓冲区
> - 形式：内存中的一个区域，落入缓冲区的分组可以发送
> - 功能：用于存放已发送，但是没有得到确认的分组
> - 必要性：需要重发时可用
>
> 发送缓冲区的大小：一次最多可以发送多少个未经确认的分组
>
> 发送缓冲区中的分组
> - 未发送的：落入发送缓冲区的分组，可以连续发送出去
> - 已经发送出去、等待确认的分组：发送缓冲区的分组只有得到确认才能删除
>
> 接收窗口（接收缓冲区）
> - 接收窗口用于控制哪些分组可以接受
> - 只有收到分组需要落入接收窗口内才允许接受，否则丢弃
> - 接收窗口尺寸 Wr=1，则只能顺序接收
> - 接收窗口尺寸 Wr>1，则可以乱序接收
>
> 接收窗口的滑动和发送确认
> - 滑动：低序号的分组到来，接收窗口移动；高序号分组乱序到来，缓存但不交付，不滑动
> - 发送确认：接收窗口尺寸=1，发送连续收到的最大的分组确认（累计确认）；接收窗口尺寸>1，收到分组、发送那个分组的确认（非累计确认）

<font color="red">流水线协议（GBN，SR）</font>

> 流水线协议：提高链路利用率
> - 允许发送方在未得到对方确认的情况下一次发送多个分组
> - 必须增加序号的范围：用多个比特表示分组的序号
> - 在发送方/接收方要有缓冲区
>
> 回退 N 步（GBN）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收端丢弃乱序到达的分组，只发送累计确认
> - 发送端拥有最老的未确认分组的定时器，当定时器超时，重传所有的未确认分组
>
> 选择重传（SR）协议
> - 发送端最多在流水线中有 N 个未确认的分组
> - 接收方对每个到来的分组单独确认（非累计确认）
> - 发送方为每个未确认的分组保持一个定时器，当定时器超时，只重发超时的未确认分组
>
> 窗口的最大尺寸
> - GBN：$2^n-1$
> - SR：$2^{n-1}$
> - 例如：$n=2$，序列号：0,1,2,3
>   - GBN=3
>   - SR=2

### TCP 协议

<font color="red">报文格式</font>

<font color="red">工作原理</font>

<font color="red">流量控制</font>

<font color="red">连接建立（三次握手）</font>

<font color="red">连接释放（四次挥手）</font>

### 拥塞控制

拥塞原因与代价

<font color="red">拥塞控制方法（端到端、网络辅助）</font>

<font color="red">TCP 拥塞控制</font>